{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SimLab Overview","text":"<p>Welcome to the documentation for the SimLab framework. This framework includes several simulation models that are designed to demonstrate and analyze various phenomena in business and economics. Here, you will find detailed information on the workings and usage of each simulation model.</p>"},{"location":"#product-popularity-simulation","title":"Product Popularity Simulation","text":"<p>The Product Popularity Simulation models the dynamics of product demand over time, considering factors like natural growth, marketing impact, and promotional campaigns.</p> <ul> <li>Learn more about the Product Popularity Simulation</li> </ul>"},{"location":"#stock-market-simulation","title":"Stock Market Simulation","text":"<p>The Stock Market Simulation provides a framework for modeling and predicting stock price movements based on various economic and psychological factors.</p> <ul> <li>Learn more about the Stock Market Simulation</li> </ul>"},{"location":"#resource-fluctuations-simulation","title":"Resource Fluctuations Simulation","text":"<p>The Resource Fluctuations Simulation models the price variability of resources over time, factoring in elements like market volatility, economic drift, and external disruptions.</p> <ul> <li>Learn more about the Resource Fluctuations Simulation</li> </ul>"},{"location":"#modelling-market-dynamics","title":"Modelling Market Dynamics","text":"<p>Each model incorporates different aspects of market behavior and is linked to classical and traditional models in economics and finance.  See Modelling Market Dynamics</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with using these simulations, visit our Getting Started guide which will help you set up and run your first simulations.</p>"},{"location":"#contribute","title":"Contribute","text":"<p>Interested in contributing to the Simulation Framework? Check out our Contribution Guidelines for more information on how you can help improve these simulations.</p>"},{"location":"#contact","title":"Contact","text":"<p>If you have any questions or feedback, please don't hesitate to Contact Us.</p>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#core-components","title":"Core Components","text":""},{"location":"api/#base-simulation","title":"Base Simulation","text":""},{"location":"api/#sim_lab.core.BaseSimulation","title":"<code>sim_lab.core.BaseSimulation</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all SimLab simulations.</p> <p>This abstract class defines the common interface and utility methods for all simulation types in the SimLab package.</p> <p>Attributes:</p> Name Type Description <code>random_seed</code> <code>Optional[int]</code> <p>Seed for random number generation to ensure reproducible results</p> Source code in <code>src/sim_lab/core/base_simulation.py</code> <pre><code>class BaseSimulation(ABC):\n    \"\"\"Base class for all SimLab simulations.\n\n    This abstract class defines the common interface and utility methods\n    for all simulation types in the SimLab package.\n\n    Attributes:\n        random_seed (Optional[int]): Seed for random number generation to ensure reproducible results\n    \"\"\"\n\n    def __init__(self, days: int, random_seed: Optional[int] = None, **kwargs):\n        \"\"\"Initialize the base simulation.\n\n        Args:\n            days (int): The duration of the simulation in days/steps.\n            random_seed (Optional[int]): Seed for random number generation. If None, random results will vary.\n            **kwargs: Additional parameters for specific simulation types.\n        \"\"\"\n        self.days = days\n        self.random_seed = random_seed\n        self._initialize_random_generators()\n\n    def _initialize_random_generators(self) -&gt; None:\n        \"\"\"Initialize random number generators with the seed.\"\"\"\n        if self.random_seed is not None:\n            random.seed(self.random_seed)\n            np.random.seed(self.random_seed)\n\n    @abstractmethod\n    def run_simulation(self) -&gt; List[Union[float, int]]:\n        \"\"\"Run the simulation and return results.\n\n        This method must be implemented by all simulation subclasses.\n\n        Returns:\n            A list of values representing the simulation results over time.\n        \"\"\"\n        pass\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset the simulation to its initial state.\n\n        This allows a simulation instance to be re-run with the same parameters.\n        \"\"\"\n        self._initialize_random_generators()\n\n    @classmethod\n    def get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n        \"\"\"Get information about the parameters required by this simulation.\n\n        Returns:\n            A dictionary mapping parameter names to their metadata (type, description, default, etc.)\n        \"\"\"\n        return {\n            'days': {\n                'type': 'int',\n                'description': 'The duration of the simulation in days/steps',\n                'required': True\n            },\n            'random_seed': {\n                'type': 'int',\n                'description': 'Seed for random number generation to ensure reproducible results',\n                'required': False,\n                'default': None\n            }\n        }\n</code></pre>"},{"location":"api/#sim_lab.core.BaseSimulation.__init__","title":"<code>__init__(days, random_seed=None, **kwargs)</code>","text":"<p>Initialize the base simulation.</p> <p>Parameters:</p> Name Type Description Default <code>days</code> <code>int</code> <p>The duration of the simulation in days/steps.</p> required <code>random_seed</code> <code>Optional[int]</code> <p>Seed for random number generation. If None, random results will vary.</p> <code>None</code> <code>**kwargs</code> <p>Additional parameters for specific simulation types.</p> <code>{}</code> Source code in <code>src/sim_lab/core/base_simulation.py</code> <pre><code>def __init__(self, days: int, random_seed: Optional[int] = None, **kwargs):\n    \"\"\"Initialize the base simulation.\n\n    Args:\n        days (int): The duration of the simulation in days/steps.\n        random_seed (Optional[int]): Seed for random number generation. If None, random results will vary.\n        **kwargs: Additional parameters for specific simulation types.\n    \"\"\"\n    self.days = days\n    self.random_seed = random_seed\n    self._initialize_random_generators()\n</code></pre>"},{"location":"api/#sim_lab.core.BaseSimulation.get_parameters_info","title":"<code>get_parameters_info()</code>  <code>classmethod</code>","text":"<p>Get information about the parameters required by this simulation.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Any]]</code> <p>A dictionary mapping parameter names to their metadata (type, description, default, etc.)</p> Source code in <code>src/sim_lab/core/base_simulation.py</code> <pre><code>@classmethod\ndef get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n    \"\"\"Get information about the parameters required by this simulation.\n\n    Returns:\n        A dictionary mapping parameter names to their metadata (type, description, default, etc.)\n    \"\"\"\n    return {\n        'days': {\n            'type': 'int',\n            'description': 'The duration of the simulation in days/steps',\n            'required': True\n        },\n        'random_seed': {\n            'type': 'int',\n            'description': 'Seed for random number generation to ensure reproducible results',\n            'required': False,\n            'default': None\n        }\n    }\n</code></pre>"},{"location":"api/#sim_lab.core.BaseSimulation.reset","title":"<code>reset()</code>","text":"<p>Reset the simulation to its initial state.</p> <p>This allows a simulation instance to be re-run with the same parameters.</p> Source code in <code>src/sim_lab/core/base_simulation.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the simulation to its initial state.\n\n    This allows a simulation instance to be re-run with the same parameters.\n    \"\"\"\n    self._initialize_random_generators()\n</code></pre>"},{"location":"api/#sim_lab.core.BaseSimulation.run_simulation","title":"<code>run_simulation()</code>  <code>abstractmethod</code>","text":"<p>Run the simulation and return results.</p> <p>This method must be implemented by all simulation subclasses.</p> <p>Returns:</p> Type Description <code>List[Union[float, int]]</code> <p>A list of values representing the simulation results over time.</p> Source code in <code>src/sim_lab/core/base_simulation.py</code> <pre><code>@abstractmethod\ndef run_simulation(self) -&gt; List[Union[float, int]]:\n    \"\"\"Run the simulation and return results.\n\n    This method must be implemented by all simulation subclasses.\n\n    Returns:\n        A list of values representing the simulation results over time.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#simulator-registry","title":"Simulator Registry","text":""},{"location":"api/#sim_lab.core.SimulatorRegistry","title":"<code>sim_lab.core.SimulatorRegistry</code>","text":"<p>Registry for simulation models.</p> <p>This class maintains a registry of all available simulation models, allowing for dynamic discovery and instantiation of simulations.</p> Source code in <code>src/sim_lab/core/registry.py</code> <pre><code>class SimulatorRegistry:\n    \"\"\"Registry for simulation models.\n\n    This class maintains a registry of all available simulation models,\n    allowing for dynamic discovery and instantiation of simulations.\n    \"\"\"\n\n    _registry: Dict[str, Type[BaseSimulation]] = {}\n\n    @classmethod\n    def register(cls, name: Optional[str] = None) -&gt; callable:\n        \"\"\"Decorator to register a simulation class.\n\n        Args:\n            name: The name to register the simulation under. If None, \n                 the class name will be used.\n\n        Returns:\n            A decorator function that registers the class.\n        \"\"\"\n        def decorator(sim_class: Type[T]) -&gt; Type[T]:\n            if not inspect.isclass(sim_class) or not issubclass(sim_class, BaseSimulation):\n                raise TypeError(f\"Class {sim_class.__name__} must be a subclass of BaseSimulation\")\n\n            sim_name = name if name is not None else sim_class.__name__\n            cls._registry[sim_name] = sim_class\n            return sim_class\n\n        return decorator\n\n    @classmethod\n    def unregister(cls, name: str) -&gt; None:\n        \"\"\"Remove a simulation from the registry.\n\n        Args:\n            name: The name of the simulation to remove.\n\n        Raises:\n            KeyError: If the simulation is not registered.\n        \"\"\"\n        if name in cls._registry:\n            del cls._registry[name]\n        else:\n            raise KeyError(f\"Simulation '{name}' is not registered\")\n\n    @classmethod\n    def get(cls, name: str) -&gt; Type[BaseSimulation]:\n        \"\"\"Get a simulation class by name.\n\n        Args:\n            name: The name of the simulation to get.\n\n        Returns:\n            The simulation class.\n\n        Raises:\n            KeyError: If the simulation is not registered.\n        \"\"\"\n        if name in cls._registry:\n            return cls._registry[name]\n        else:\n            raise KeyError(f\"Simulation '{name}' is not registered\")\n\n    @classmethod\n    def list_simulators(cls) -&gt; List[str]:\n        \"\"\"List all registered simulations.\n\n        Returns:\n            A list of simulation names.\n        \"\"\"\n        return list(cls._registry.keys())\n\n    @classmethod\n    def create(cls, name: str, **kwargs: Any) -&gt; BaseSimulation:\n        \"\"\"Create an instance of a simulation.\n\n        Args:\n            name: The name of the simulation to create.\n            **kwargs: Parameters to pass to the simulation constructor.\n\n        Returns:\n            A new instance of the requested simulation.\n\n        Raises:\n            KeyError: If the simulation is not registered.\n        \"\"\"\n        sim_class = cls.get(name)\n        return sim_class(**kwargs)\n\n    @classmethod\n    def load_simulator_from_path(cls, module_path: str, class_name: str, \n                                register_as: Optional[str] = None) -&gt; Type[BaseSimulation]:\n        \"\"\"Load a simulator class from a module path and register it.\n\n        Args:\n            module_path: The dotted path to the module (e.g. 'sim_lab.custom.my_simulation').\n            class_name: The name of the class to load.\n            register_as: The name to register the simulation under. If None,\n                         the class name will be used.\n\n        Returns:\n            The loaded simulation class.\n\n        Raises:\n            ImportError: If the module or class cannot be loaded.\n            TypeError: If the class is not a subclass of BaseSimulation.\n        \"\"\"\n        try:\n            module = importlib.import_module(module_path)\n            sim_class = getattr(module, class_name)\n\n            if not inspect.isclass(sim_class) or not issubclass(sim_class, BaseSimulation):\n                raise TypeError(f\"Class {class_name} must be a subclass of BaseSimulation\")\n\n            reg_name = register_as if register_as is not None else class_name\n            cls._registry[reg_name] = sim_class\n            return sim_class\n\n        except ImportError:\n            raise ImportError(f\"Could not import module '{module_path}'\")\n        except AttributeError:\n            raise ImportError(f\"Module '{module_path}' has no class named '{class_name}'\")\n</code></pre>"},{"location":"api/#sim_lab.core.SimulatorRegistry.create","title":"<code>create(name, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create an instance of a simulation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the simulation to create.</p> required <code>**kwargs</code> <code>Any</code> <p>Parameters to pass to the simulation constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BaseSimulation</code> <p>A new instance of the requested simulation.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the simulation is not registered.</p> Source code in <code>src/sim_lab/core/registry.py</code> <pre><code>@classmethod\ndef create(cls, name: str, **kwargs: Any) -&gt; BaseSimulation:\n    \"\"\"Create an instance of a simulation.\n\n    Args:\n        name: The name of the simulation to create.\n        **kwargs: Parameters to pass to the simulation constructor.\n\n    Returns:\n        A new instance of the requested simulation.\n\n    Raises:\n        KeyError: If the simulation is not registered.\n    \"\"\"\n    sim_class = cls.get(name)\n    return sim_class(**kwargs)\n</code></pre>"},{"location":"api/#sim_lab.core.SimulatorRegistry.get","title":"<code>get(name)</code>  <code>classmethod</code>","text":"<p>Get a simulation class by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the simulation to get.</p> required <p>Returns:</p> Type Description <code>Type[BaseSimulation]</code> <p>The simulation class.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the simulation is not registered.</p> Source code in <code>src/sim_lab/core/registry.py</code> <pre><code>@classmethod\ndef get(cls, name: str) -&gt; Type[BaseSimulation]:\n    \"\"\"Get a simulation class by name.\n\n    Args:\n        name: The name of the simulation to get.\n\n    Returns:\n        The simulation class.\n\n    Raises:\n        KeyError: If the simulation is not registered.\n    \"\"\"\n    if name in cls._registry:\n        return cls._registry[name]\n    else:\n        raise KeyError(f\"Simulation '{name}' is not registered\")\n</code></pre>"},{"location":"api/#sim_lab.core.SimulatorRegistry.list_simulators","title":"<code>list_simulators()</code>  <code>classmethod</code>","text":"<p>List all registered simulations.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of simulation names.</p> Source code in <code>src/sim_lab/core/registry.py</code> <pre><code>@classmethod\ndef list_simulators(cls) -&gt; List[str]:\n    \"\"\"List all registered simulations.\n\n    Returns:\n        A list of simulation names.\n    \"\"\"\n    return list(cls._registry.keys())\n</code></pre>"},{"location":"api/#sim_lab.core.SimulatorRegistry.load_simulator_from_path","title":"<code>load_simulator_from_path(module_path, class_name, register_as=None)</code>  <code>classmethod</code>","text":"<p>Load a simulator class from a module path and register it.</p> <p>Parameters:</p> Name Type Description Default <code>module_path</code> <code>str</code> <p>The dotted path to the module (e.g. 'sim_lab.custom.my_simulation').</p> required <code>class_name</code> <code>str</code> <p>The name of the class to load.</p> required <code>register_as</code> <code>Optional[str]</code> <p>The name to register the simulation under. If None,          the class name will be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>Type[BaseSimulation]</code> <p>The loaded simulation class.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the module or class cannot be loaded.</p> <code>TypeError</code> <p>If the class is not a subclass of BaseSimulation.</p> Source code in <code>src/sim_lab/core/registry.py</code> <pre><code>@classmethod\ndef load_simulator_from_path(cls, module_path: str, class_name: str, \n                            register_as: Optional[str] = None) -&gt; Type[BaseSimulation]:\n    \"\"\"Load a simulator class from a module path and register it.\n\n    Args:\n        module_path: The dotted path to the module (e.g. 'sim_lab.custom.my_simulation').\n        class_name: The name of the class to load.\n        register_as: The name to register the simulation under. If None,\n                     the class name will be used.\n\n    Returns:\n        The loaded simulation class.\n\n    Raises:\n        ImportError: If the module or class cannot be loaded.\n        TypeError: If the class is not a subclass of BaseSimulation.\n    \"\"\"\n    try:\n        module = importlib.import_module(module_path)\n        sim_class = getattr(module, class_name)\n\n        if not inspect.isclass(sim_class) or not issubclass(sim_class, BaseSimulation):\n            raise TypeError(f\"Class {class_name} must be a subclass of BaseSimulation\")\n\n        reg_name = register_as if register_as is not None else class_name\n        cls._registry[reg_name] = sim_class\n        return sim_class\n\n    except ImportError:\n        raise ImportError(f\"Could not import module '{module_path}'\")\n    except AttributeError:\n        raise ImportError(f\"Module '{module_path}' has no class named '{class_name}'\")\n</code></pre>"},{"location":"api/#sim_lab.core.SimulatorRegistry.register","title":"<code>register(name=None)</code>  <code>classmethod</code>","text":"<p>Decorator to register a simulation class.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name to register the simulation under. If None,   the class name will be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>callable</code> <p>A decorator function that registers the class.</p> Source code in <code>src/sim_lab/core/registry.py</code> <pre><code>@classmethod\ndef register(cls, name: Optional[str] = None) -&gt; callable:\n    \"\"\"Decorator to register a simulation class.\n\n    Args:\n        name: The name to register the simulation under. If None, \n             the class name will be used.\n\n    Returns:\n        A decorator function that registers the class.\n    \"\"\"\n    def decorator(sim_class: Type[T]) -&gt; Type[T]:\n        if not inspect.isclass(sim_class) or not issubclass(sim_class, BaseSimulation):\n            raise TypeError(f\"Class {sim_class.__name__} must be a subclass of BaseSimulation\")\n\n        sim_name = name if name is not None else sim_class.__name__\n        cls._registry[sim_name] = sim_class\n        return sim_class\n\n    return decorator\n</code></pre>"},{"location":"api/#sim_lab.core.SimulatorRegistry.unregister","title":"<code>unregister(name)</code>  <code>classmethod</code>","text":"<p>Remove a simulation from the registry.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the simulation to remove.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the simulation is not registered.</p> Source code in <code>src/sim_lab/core/registry.py</code> <pre><code>@classmethod\ndef unregister(cls, name: str) -&gt; None:\n    \"\"\"Remove a simulation from the registry.\n\n    Args:\n        name: The name of the simulation to remove.\n\n    Raises:\n        KeyError: If the simulation is not registered.\n    \"\"\"\n    if name in cls._registry:\n        del cls._registry[name]\n    else:\n        raise KeyError(f\"Simulation '{name}' is not registered\")\n</code></pre>"},{"location":"api/#basic-simulations","title":"Basic Simulations","text":""},{"location":"api/#product-popularity-simulation-class","title":"Product Popularity Simulation Class","text":""},{"location":"api/#sim_lab.core.ProductPopularitySimulation","title":"<code>sim_lab.core.ProductPopularitySimulation</code>","text":"<p>               Bases: <code>BaseSimulation</code></p> <p>A simulation class to model the dynamics of product popularity over time, incorporating factors like natural growth, marketing impact, and promotional campaigns.</p> <p>Attributes:</p> Name Type Description <code>start_demand</code> <code>int</code> <p>Initial demand for the product.</p> <code>days</code> <code>int</code> <p>Duration of the simulation in days.</p> <code>growth_rate</code> <code>float</code> <p>Natural growth rate of product demand.</p> <code>marketing_impact</code> <code>float</code> <p>Impact of ongoing marketing efforts on demand.</p> <code>promotion_day</code> <code>Optional[int]</code> <p>Day on which a major marketing campaign starts (default is None).</p> <code>promotion_effectiveness</code> <code>float</code> <p>Effectiveness of the marketing campaign.</p> <code>random_seed</code> <code>Optional[int]</code> <p>The seed for the random number generator to ensure reproducibility (default is None).</p> <p>Methods:</p> Name Description <code>run_simulation</code> <p>Runs the simulation and returns a list of demand values over time.</p> Source code in <code>src/sim_lab/core/product_popularity_simulation.py</code> <pre><code>@SimulatorRegistry.register(\"ProductPopularity\")\nclass ProductPopularitySimulation(BaseSimulation):\n    \"\"\"\n    A simulation class to model the dynamics of product popularity over time,\n    incorporating factors like natural growth, marketing impact, and promotional campaigns.\n\n    Attributes:\n        start_demand (int): Initial demand for the product.\n        days (int): Duration of the simulation in days.\n        growth_rate (float): Natural growth rate of product demand.\n        marketing_impact (float): Impact of ongoing marketing efforts on demand.\n        promotion_day (Optional[int]): Day on which a major marketing campaign starts (default is None).\n        promotion_effectiveness (float): Effectiveness of the marketing campaign.\n        random_seed (Optional[int]): The seed for the random number generator to ensure reproducibility (default is None).\n\n    Methods:\n        run_simulation(): Runs the simulation and returns a list of demand values over time.\n    \"\"\"\n\n    def __init__(\n        self, start_demand: float, days: int, growth_rate: float, marketing_impact: float,\n        promotion_day: Optional[int] = None, promotion_effectiveness: float = 0,\n        random_seed: Optional[int] = None\n    ) -&gt; None:\n        \"\"\"\n        Initializes the ProductPopularitySimulation with all necessary parameters.\n\n        Parameters:\n            start_demand (int): The initial level of demand for the product.\n            days (int): The total number of days to simulate.\n            growth_rate (float): The natural daily growth rate of demand, as a decimal.\n            marketing_impact (float): Daily impact of marketing on demand, as a decimal.\n            promotion_day (Optional[int]): The specific day on which a promotional event occurs (defaults to None).\n            promotion_effectiveness (float): Multiplicative impact of the promotion on demand.\n            random_seed (Optional[int]): Seed for the random number generator to ensure reproducible results (defaults to None).\n        \"\"\"\n        super().__init__(days=days, random_seed=random_seed)\n        self.start_demand = start_demand\n        self.growth_rate = growth_rate\n        self.marketing_impact = marketing_impact\n        self.promotion_day = promotion_day\n        self.promotion_effectiveness = promotion_effectiveness\n\n    def run_simulation(self) -&gt; List[float]:\n        \"\"\"\n        Simulates the demand for a product over a specified number of days based on the initial settings.\n\n        Returns:\n            List[int]: A list containing the demand for the product for each day of the simulation.\n        \"\"\"\n        # Base class handles random seed initialization\n        self.reset()\n\n        demand = [self.start_demand]\n        for day in range(1, self.days):\n            previous_demand = demand[-1]\n            natural_growth = previous_demand * (1 + self.growth_rate)\n            marketing_influence = previous_demand * self.marketing_impact\n\n            new_demand = natural_growth + marketing_influence\n\n            if day == self.promotion_day:\n                new_demand = (natural_growth + marketing_influence) * (1 + self.promotion_effectiveness)\n\n            demand.append(new_demand)\n\n        return demand\n\n    @classmethod\n    def get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n        \"\"\"Get information about the parameters required by this simulation.\n\n        Returns:\n            A dictionary mapping parameter names to their metadata (type, description, default, etc.)\n        \"\"\"\n        # Get base parameters from parent class\n        params = super().get_parameters_info()\n\n        # Add class-specific parameters\n        params.update({\n            'start_demand': {\n                'type': 'float',\n                'description': 'The initial level of demand for the product',\n                'required': True\n            },\n            'growth_rate': {\n                'type': 'float',\n                'description': 'The natural daily growth rate of demand, as a decimal',\n                'required': True\n            },\n            'marketing_impact': {\n                'type': 'float',\n                'description': 'Daily impact of marketing on demand, as a decimal',\n                'required': True\n            },\n            'promotion_day': {\n                'type': 'int',\n                'description': 'The specific day on which a promotional event occurs',\n                'required': False,\n                'default': None\n            },\n            'promotion_effectiveness': {\n                'type': 'float',\n                'description': 'Multiplicative impact of the promotion on demand',\n                'required': False,\n                'default': 0\n            }\n        })\n\n        return params\n</code></pre>"},{"location":"api/#sim_lab.core.ProductPopularitySimulation.__init__","title":"<code>__init__(start_demand, days, growth_rate, marketing_impact, promotion_day=None, promotion_effectiveness=0, random_seed=None)</code>","text":"<p>Initializes the ProductPopularitySimulation with all necessary parameters.</p> <p>Parameters:</p> Name Type Description Default <code>start_demand</code> <code>int</code> <p>The initial level of demand for the product.</p> required <code>days</code> <code>int</code> <p>The total number of days to simulate.</p> required <code>growth_rate</code> <code>float</code> <p>The natural daily growth rate of demand, as a decimal.</p> required <code>marketing_impact</code> <code>float</code> <p>Daily impact of marketing on demand, as a decimal.</p> required <code>promotion_day</code> <code>Optional[int]</code> <p>The specific day on which a promotional event occurs (defaults to None).</p> <code>None</code> <code>promotion_effectiveness</code> <code>float</code> <p>Multiplicative impact of the promotion on demand.</p> <code>0</code> <code>random_seed</code> <code>Optional[int]</code> <p>Seed for the random number generator to ensure reproducible results (defaults to None).</p> <code>None</code> Source code in <code>src/sim_lab/core/product_popularity_simulation.py</code> <pre><code>def __init__(\n    self, start_demand: float, days: int, growth_rate: float, marketing_impact: float,\n    promotion_day: Optional[int] = None, promotion_effectiveness: float = 0,\n    random_seed: Optional[int] = None\n) -&gt; None:\n    \"\"\"\n    Initializes the ProductPopularitySimulation with all necessary parameters.\n\n    Parameters:\n        start_demand (int): The initial level of demand for the product.\n        days (int): The total number of days to simulate.\n        growth_rate (float): The natural daily growth rate of demand, as a decimal.\n        marketing_impact (float): Daily impact of marketing on demand, as a decimal.\n        promotion_day (Optional[int]): The specific day on which a promotional event occurs (defaults to None).\n        promotion_effectiveness (float): Multiplicative impact of the promotion on demand.\n        random_seed (Optional[int]): Seed for the random number generator to ensure reproducible results (defaults to None).\n    \"\"\"\n    super().__init__(days=days, random_seed=random_seed)\n    self.start_demand = start_demand\n    self.growth_rate = growth_rate\n    self.marketing_impact = marketing_impact\n    self.promotion_day = promotion_day\n    self.promotion_effectiveness = promotion_effectiveness\n</code></pre>"},{"location":"api/#sim_lab.core.ProductPopularitySimulation.get_parameters_info","title":"<code>get_parameters_info()</code>  <code>classmethod</code>","text":"<p>Get information about the parameters required by this simulation.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Any]]</code> <p>A dictionary mapping parameter names to their metadata (type, description, default, etc.)</p> Source code in <code>src/sim_lab/core/product_popularity_simulation.py</code> <pre><code>@classmethod\ndef get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n    \"\"\"Get information about the parameters required by this simulation.\n\n    Returns:\n        A dictionary mapping parameter names to their metadata (type, description, default, etc.)\n    \"\"\"\n    # Get base parameters from parent class\n    params = super().get_parameters_info()\n\n    # Add class-specific parameters\n    params.update({\n        'start_demand': {\n            'type': 'float',\n            'description': 'The initial level of demand for the product',\n            'required': True\n        },\n        'growth_rate': {\n            'type': 'float',\n            'description': 'The natural daily growth rate of demand, as a decimal',\n            'required': True\n        },\n        'marketing_impact': {\n            'type': 'float',\n            'description': 'Daily impact of marketing on demand, as a decimal',\n            'required': True\n        },\n        'promotion_day': {\n            'type': 'int',\n            'description': 'The specific day on which a promotional event occurs',\n            'required': False,\n            'default': None\n        },\n        'promotion_effectiveness': {\n            'type': 'float',\n            'description': 'Multiplicative impact of the promotion on demand',\n            'required': False,\n            'default': 0\n        }\n    })\n\n    return params\n</code></pre>"},{"location":"api/#sim_lab.core.ProductPopularitySimulation.run_simulation","title":"<code>run_simulation()</code>","text":"<p>Simulates the demand for a product over a specified number of days based on the initial settings.</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>List[int]: A list containing the demand for the product for each day of the simulation.</p> Source code in <code>src/sim_lab/core/product_popularity_simulation.py</code> <pre><code>def run_simulation(self) -&gt; List[float]:\n    \"\"\"\n    Simulates the demand for a product over a specified number of days based on the initial settings.\n\n    Returns:\n        List[int]: A list containing the demand for the product for each day of the simulation.\n    \"\"\"\n    # Base class handles random seed initialization\n    self.reset()\n\n    demand = [self.start_demand]\n    for day in range(1, self.days):\n        previous_demand = demand[-1]\n        natural_growth = previous_demand * (1 + self.growth_rate)\n        marketing_influence = previous_demand * self.marketing_impact\n\n        new_demand = natural_growth + marketing_influence\n\n        if day == self.promotion_day:\n            new_demand = (natural_growth + marketing_influence) * (1 + self.promotion_effectiveness)\n\n        demand.append(new_demand)\n\n    return demand\n</code></pre>"},{"location":"api/#resource-fluctuation-simulation-class","title":"Resource Fluctuation Simulation Class","text":""},{"location":"api/#sim_lab.core.ResourceFluctuationsSimulation","title":"<code>sim_lab.core.ResourceFluctuationsSimulation</code>","text":"<p>               Bases: <code>BaseSimulation</code></p> <p>A simulation class to model the fluctuations of resource prices over time, considering factors like volatility, market trends (drift), and supply disruptions.</p> <p>Attributes:</p> Name Type Description <code>start_price</code> <code>float</code> <p>The initial price of the resource.</p> <code>days</code> <code>int</code> <p>The duration of the simulation in days.</p> <code>volatility</code> <code>float</code> <p>The volatility of price changes, representing day-to-day variability.</p> <code>drift</code> <code>float</code> <p>The average daily price change, indicating the trend over time.</p> <code>supply_disruption_day</code> <code>Optional[int]</code> <p>The specific day a supply disruption occurs (default is None).</p> <code>disruption_severity</code> <code>float</code> <p>The magnitude of the disruption's impact on price (default is 0).</p> <code>random_seed</code> <code>Optional[int]</code> <p>The seed for the random number generator to ensure reproducibility (default is None).</p> Source code in <code>src/sim_lab/core/resource_fluctuations_simulation.py</code> <pre><code>@SimulatorRegistry.register(\"ResourceFluctuations\")\nclass ResourceFluctuationsSimulation(BaseSimulation):\n    \"\"\"\n    A simulation class to model the fluctuations of resource prices over time,\n    considering factors like volatility, market trends (drift), and supply disruptions.\n\n    Attributes:\n        start_price (float): The initial price of the resource.\n        days (int): The duration of the simulation in days.\n        volatility (float): The volatility of price changes, representing day-to-day variability.\n        drift (float): The average daily price change, indicating the trend over time.\n        supply_disruption_day (Optional[int]): The specific day a supply disruption occurs (default is None).\n        disruption_severity (float): The magnitude of the disruption's impact on price (default is 0).\n        random_seed (Optional[int]): The seed for the random number generator to ensure reproducibility (default is None).\n    \"\"\"\n    def __init__(self, start_price: float, days: int, volatility: float, drift: float,\n                 supply_disruption_day: Optional[int] = None, disruption_severity: float = 0,\n                 random_seed: Optional[int] = None) -&gt; None:\n        \"\"\"\n        Initializes the ResourceSimulation with all necessary parameters.\n\n        Parameters:\n            start_price (float): The initial price of the resource.\n            days (int): The total number of days to simulate.\n            volatility (float): The volatility of the resource price, representing the randomness of day-to-day price changes.\n            drift (float): The expected daily percentage change in price, which can be positive or negative.\n            supply_disruption_day (Optional[int]): Day on which a supply disruption occurs (defaults to None).\n            disruption_severity (float): The severity of the supply disruption, affecting prices multiplicatively.\n            random_seed (Optional[int]): Seed for the random number generator to ensure reproducible results (defaults to None).\n        \"\"\"\n        super().__init__(days=days, random_seed=random_seed)\n        self.start_price = start_price\n        self.volatility = volatility\n        self.drift = drift\n        self.supply_disruption_day = supply_disruption_day\n        self.disruption_severity = disruption_severity\n\n    def run_simulation(self) -&gt; List[float]:\n        \"\"\"\n        Simulates the price of the resource over a specified number of days based on the initial settings.\n\n        Returns:\n            List[float]: A list containing the price of the resource for each day of the simulation.\n        \"\"\"\n        # Base class handles random seed initialization\n        self.reset()\n\n        prices = [self.start_price]\n        for day in range(1, self.days):\n            previous_price = prices[-1]\n            random_change = np.random.normal(self.drift, self.volatility)\n            new_price = previous_price * (1 + random_change)\n\n            if day == self.supply_disruption_day:\n                new_price = previous_price * (1 + self.disruption_severity)\n\n            prices.append(new_price)\n\n        return prices\n\n    @classmethod\n    def get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n        \"\"\"Get information about the parameters required by this simulation.\n\n        Returns:\n            A dictionary mapping parameter names to their metadata (type, description, default, etc.)\n        \"\"\"\n        # Get base parameters from parent class\n        params = super().get_parameters_info()\n\n        # Add class-specific parameters\n        params.update({\n            'start_price': {\n                'type': 'float',\n                'description': 'The initial price of the resource',\n                'required': True\n            },\n            'volatility': {\n                'type': 'float',\n                'description': 'The volatility of resource price changes, representing day-to-day variability',\n                'required': True\n            },\n            'drift': {\n                'type': 'float',\n                'description': 'The average daily price change, indicating the trend over time',\n                'required': True\n            },\n            'supply_disruption_day': {\n                'type': 'int',\n                'description': 'The specific day a supply disruption occurs',\n                'required': False,\n                'default': None\n            },\n            'disruption_severity': {\n                'type': 'float',\n                'description': 'The magnitude of the disruption\\'s impact on prices',\n                'required': False,\n                'default': 0\n            }\n        })\n\n        return params\n</code></pre>"},{"location":"api/#sim_lab.core.ResourceFluctuationsSimulation.__init__","title":"<code>__init__(start_price, days, volatility, drift, supply_disruption_day=None, disruption_severity=0, random_seed=None)</code>","text":"<p>Initializes the ResourceSimulation with all necessary parameters.</p> <p>Parameters:</p> Name Type Description Default <code>start_price</code> <code>float</code> <p>The initial price of the resource.</p> required <code>days</code> <code>int</code> <p>The total number of days to simulate.</p> required <code>volatility</code> <code>float</code> <p>The volatility of the resource price, representing the randomness of day-to-day price changes.</p> required <code>drift</code> <code>float</code> <p>The expected daily percentage change in price, which can be positive or negative.</p> required <code>supply_disruption_day</code> <code>Optional[int]</code> <p>Day on which a supply disruption occurs (defaults to None).</p> <code>None</code> <code>disruption_severity</code> <code>float</code> <p>The severity of the supply disruption, affecting prices multiplicatively.</p> <code>0</code> <code>random_seed</code> <code>Optional[int]</code> <p>Seed for the random number generator to ensure reproducible results (defaults to None).</p> <code>None</code> Source code in <code>src/sim_lab/core/resource_fluctuations_simulation.py</code> <pre><code>def __init__(self, start_price: float, days: int, volatility: float, drift: float,\n             supply_disruption_day: Optional[int] = None, disruption_severity: float = 0,\n             random_seed: Optional[int] = None) -&gt; None:\n    \"\"\"\n    Initializes the ResourceSimulation with all necessary parameters.\n\n    Parameters:\n        start_price (float): The initial price of the resource.\n        days (int): The total number of days to simulate.\n        volatility (float): The volatility of the resource price, representing the randomness of day-to-day price changes.\n        drift (float): The expected daily percentage change in price, which can be positive or negative.\n        supply_disruption_day (Optional[int]): Day on which a supply disruption occurs (defaults to None).\n        disruption_severity (float): The severity of the supply disruption, affecting prices multiplicatively.\n        random_seed (Optional[int]): Seed for the random number generator to ensure reproducible results (defaults to None).\n    \"\"\"\n    super().__init__(days=days, random_seed=random_seed)\n    self.start_price = start_price\n    self.volatility = volatility\n    self.drift = drift\n    self.supply_disruption_day = supply_disruption_day\n    self.disruption_severity = disruption_severity\n</code></pre>"},{"location":"api/#sim_lab.core.ResourceFluctuationsSimulation.get_parameters_info","title":"<code>get_parameters_info()</code>  <code>classmethod</code>","text":"<p>Get information about the parameters required by this simulation.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Any]]</code> <p>A dictionary mapping parameter names to their metadata (type, description, default, etc.)</p> Source code in <code>src/sim_lab/core/resource_fluctuations_simulation.py</code> <pre><code>@classmethod\ndef get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n    \"\"\"Get information about the parameters required by this simulation.\n\n    Returns:\n        A dictionary mapping parameter names to their metadata (type, description, default, etc.)\n    \"\"\"\n    # Get base parameters from parent class\n    params = super().get_parameters_info()\n\n    # Add class-specific parameters\n    params.update({\n        'start_price': {\n            'type': 'float',\n            'description': 'The initial price of the resource',\n            'required': True\n        },\n        'volatility': {\n            'type': 'float',\n            'description': 'The volatility of resource price changes, representing day-to-day variability',\n            'required': True\n        },\n        'drift': {\n            'type': 'float',\n            'description': 'The average daily price change, indicating the trend over time',\n            'required': True\n        },\n        'supply_disruption_day': {\n            'type': 'int',\n            'description': 'The specific day a supply disruption occurs',\n            'required': False,\n            'default': None\n        },\n        'disruption_severity': {\n            'type': 'float',\n            'description': 'The magnitude of the disruption\\'s impact on prices',\n            'required': False,\n            'default': 0\n        }\n    })\n\n    return params\n</code></pre>"},{"location":"api/#sim_lab.core.ResourceFluctuationsSimulation.run_simulation","title":"<code>run_simulation()</code>","text":"<p>Simulates the price of the resource over a specified number of days based on the initial settings.</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>List[float]: A list containing the price of the resource for each day of the simulation.</p> Source code in <code>src/sim_lab/core/resource_fluctuations_simulation.py</code> <pre><code>def run_simulation(self) -&gt; List[float]:\n    \"\"\"\n    Simulates the price of the resource over a specified number of days based on the initial settings.\n\n    Returns:\n        List[float]: A list containing the price of the resource for each day of the simulation.\n    \"\"\"\n    # Base class handles random seed initialization\n    self.reset()\n\n    prices = [self.start_price]\n    for day in range(1, self.days):\n        previous_price = prices[-1]\n        random_change = np.random.normal(self.drift, self.volatility)\n        new_price = previous_price * (1 + random_change)\n\n        if day == self.supply_disruption_day:\n            new_price = previous_price * (1 + self.disruption_severity)\n\n        prices.append(new_price)\n\n    return prices\n</code></pre>"},{"location":"api/#stock-market-simulation-class","title":"Stock Market Simulation Class","text":""},{"location":"api/#sim_lab.core.StockMarketSimulation","title":"<code>sim_lab.core.StockMarketSimulation</code>","text":"<p>               Bases: <code>BaseSimulation</code></p> <p>A simulation class to model the fluctuations of stock prices over time, accounting for volatility, general market trends (drift), and specific market events.</p> <p>Attributes:</p> Name Type Description <code>start_price</code> <code>float</code> <p>The initial price of the stock.</p> <code>days</code> <code>int</code> <p>The duration of the simulation in days.</p> <code>volatility</code> <code>float</code> <p>The volatility of stock price changes, representing day-to-day variability.</p> <code>drift</code> <code>float</code> <p>The average daily price change, indicating the trend over time.</p> <code>event_day</code> <code>Optional[int]</code> <p>The specific day a major market event occurs (default is None).</p> <code>event_impact</code> <code>float</code> <p>The magnitude of the event's impact on stock prices (default is 0).</p> <code>random_seed</code> <code>Optional[int]</code> <p>The seed for the random number generator to ensure reproducibility (default is None).</p> <p>Methods:</p> Name Description <code>run_simulation</code> <p>Runs the simulation and returns a list of stock prices over the simulation period.</p> Source code in <code>src/sim_lab/core/stock_market_simulation.py</code> <pre><code>@SimulatorRegistry.register(\"StockMarket\")\nclass StockMarketSimulation(BaseSimulation):\n    \"\"\"\n    A simulation class to model the fluctuations of stock prices over time, accounting for volatility,\n    general market trends (drift), and specific market events.\n\n    Attributes:\n        start_price (float): The initial price of the stock.\n        days (int): The duration of the simulation in days.\n        volatility (float): The volatility of stock price changes, representing day-to-day variability.\n        drift (float): The average daily price change, indicating the trend over time.\n        event_day (Optional[int]): The specific day a major market event occurs (default is None).\n        event_impact (float): The magnitude of the event's impact on stock prices (default is 0).\n        random_seed (Optional[int]): The seed for the random number generator to ensure reproducibility (default is None).\n\n    Methods:\n        run_simulation(): Runs the simulation and returns a list of stock prices over the simulation period.\n    \"\"\"\n\n    def __init__(\n        self, start_price: float, days: int, volatility: float, drift: float,\n        event_day: Optional[int] = None, event_impact: float = 0,\n        random_seed: Optional[int] = None\n    ) -&gt; None:\n        \"\"\"\n        Initializes the StockMarketSimulation with all necessary parameters.\n\n        Parameters:\n            start_price (float): The initial stock price.\n            days (int): The total number of days to simulate.\n            volatility (float): The volatility of the stock price, representing the randomness of day-to-day price changes.\n            drift (float): The expected daily percentage change in price, which can be positive or negative.\n            event_day (Optional[int]): Day on which a major market event occurs (defaults to None).\n            event_impact (float): The severity of the market event, affecting prices multiplicatively.\n            random_seed (Optional[int]): Seed for the random number generator to ensure reproducible results (defaults to None).\n        \"\"\"\n        super().__init__(days=days, random_seed=random_seed)\n        self.start_price = start_price\n        self.volatility = volatility\n        self.drift = drift\n        self.event_day = event_day\n        self.event_impact = event_impact\n\n    def run_simulation(self) -&gt; List[float]:\n        \"\"\"\n        Simulates the stock price over a specified number of days based on the initial settings.\n\n        Returns:\n            List[float]: A list containing the stock prices for each day of the simulation.\n        \"\"\"\n        # Base class handles random seed initialization\n        self.reset()\n\n        prices = [self.start_price]\n        for day in range(1, self.days):\n            previous_price = prices[-1]\n            random_change = np.random.normal(self.drift, self.volatility)\n            new_price = previous_price * (1 + random_change)\n\n            if day == self.event_day:\n                new_price = previous_price * (1 + self.event_impact)\n\n            prices.append(new_price)\n\n        return prices\n\n    @classmethod\n    def get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n        \"\"\"Get information about the parameters required by this simulation.\n\n        Returns:\n            A dictionary mapping parameter names to their metadata (type, description, default, etc.)\n        \"\"\"\n        # Get base parameters from parent class\n        params = super().get_parameters_info()\n\n        # Add class-specific parameters\n        params.update({\n            'start_price': {\n                'type': 'float',\n                'description': 'The initial price of the stock',\n                'required': True\n            },\n            'volatility': {\n                'type': 'float',\n                'description': 'The volatility of stock price changes, representing day-to-day variability',\n                'required': True\n            },\n            'drift': {\n                'type': 'float',\n                'description': 'The average daily price change, indicating the trend over time',\n                'required': True\n            },\n            'event_day': {\n                'type': 'int',\n                'description': 'The specific day a major market event occurs',\n                'required': False,\n                'default': None\n            },\n            'event_impact': {\n                'type': 'float',\n                'description': 'The magnitude of the event\\'s impact on stock prices',\n                'required': False,\n                'default': 0\n            }\n        })\n\n        return params\n</code></pre>"},{"location":"api/#sim_lab.core.StockMarketSimulation.__init__","title":"<code>__init__(start_price, days, volatility, drift, event_day=None, event_impact=0, random_seed=None)</code>","text":"<p>Initializes the StockMarketSimulation with all necessary parameters.</p> <p>Parameters:</p> Name Type Description Default <code>start_price</code> <code>float</code> <p>The initial stock price.</p> required <code>days</code> <code>int</code> <p>The total number of days to simulate.</p> required <code>volatility</code> <code>float</code> <p>The volatility of the stock price, representing the randomness of day-to-day price changes.</p> required <code>drift</code> <code>float</code> <p>The expected daily percentage change in price, which can be positive or negative.</p> required <code>event_day</code> <code>Optional[int]</code> <p>Day on which a major market event occurs (defaults to None).</p> <code>None</code> <code>event_impact</code> <code>float</code> <p>The severity of the market event, affecting prices multiplicatively.</p> <code>0</code> <code>random_seed</code> <code>Optional[int]</code> <p>Seed for the random number generator to ensure reproducible results (defaults to None).</p> <code>None</code> Source code in <code>src/sim_lab/core/stock_market_simulation.py</code> <pre><code>def __init__(\n    self, start_price: float, days: int, volatility: float, drift: float,\n    event_day: Optional[int] = None, event_impact: float = 0,\n    random_seed: Optional[int] = None\n) -&gt; None:\n    \"\"\"\n    Initializes the StockMarketSimulation with all necessary parameters.\n\n    Parameters:\n        start_price (float): The initial stock price.\n        days (int): The total number of days to simulate.\n        volatility (float): The volatility of the stock price, representing the randomness of day-to-day price changes.\n        drift (float): The expected daily percentage change in price, which can be positive or negative.\n        event_day (Optional[int]): Day on which a major market event occurs (defaults to None).\n        event_impact (float): The severity of the market event, affecting prices multiplicatively.\n        random_seed (Optional[int]): Seed for the random number generator to ensure reproducible results (defaults to None).\n    \"\"\"\n    super().__init__(days=days, random_seed=random_seed)\n    self.start_price = start_price\n    self.volatility = volatility\n    self.drift = drift\n    self.event_day = event_day\n    self.event_impact = event_impact\n</code></pre>"},{"location":"api/#sim_lab.core.StockMarketSimulation.get_parameters_info","title":"<code>get_parameters_info()</code>  <code>classmethod</code>","text":"<p>Get information about the parameters required by this simulation.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Any]]</code> <p>A dictionary mapping parameter names to their metadata (type, description, default, etc.)</p> Source code in <code>src/sim_lab/core/stock_market_simulation.py</code> <pre><code>@classmethod\ndef get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n    \"\"\"Get information about the parameters required by this simulation.\n\n    Returns:\n        A dictionary mapping parameter names to their metadata (type, description, default, etc.)\n    \"\"\"\n    # Get base parameters from parent class\n    params = super().get_parameters_info()\n\n    # Add class-specific parameters\n    params.update({\n        'start_price': {\n            'type': 'float',\n            'description': 'The initial price of the stock',\n            'required': True\n        },\n        'volatility': {\n            'type': 'float',\n            'description': 'The volatility of stock price changes, representing day-to-day variability',\n            'required': True\n        },\n        'drift': {\n            'type': 'float',\n            'description': 'The average daily price change, indicating the trend over time',\n            'required': True\n        },\n        'event_day': {\n            'type': 'int',\n            'description': 'The specific day a major market event occurs',\n            'required': False,\n            'default': None\n        },\n        'event_impact': {\n            'type': 'float',\n            'description': 'The magnitude of the event\\'s impact on stock prices',\n            'required': False,\n            'default': 0\n        }\n    })\n\n    return params\n</code></pre>"},{"location":"api/#sim_lab.core.StockMarketSimulation.run_simulation","title":"<code>run_simulation()</code>","text":"<p>Simulates the stock price over a specified number of days based on the initial settings.</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>List[float]: A list containing the stock prices for each day of the simulation.</p> Source code in <code>src/sim_lab/core/stock_market_simulation.py</code> <pre><code>def run_simulation(self) -&gt; List[float]:\n    \"\"\"\n    Simulates the stock price over a specified number of days based on the initial settings.\n\n    Returns:\n        List[float]: A list containing the stock prices for each day of the simulation.\n    \"\"\"\n    # Base class handles random seed initialization\n    self.reset()\n\n    prices = [self.start_price]\n    for day in range(1, self.days):\n        previous_price = prices[-1]\n        random_change = np.random.normal(self.drift, self.volatility)\n        new_price = previous_price * (1 + random_change)\n\n        if day == self.event_day:\n            new_price = previous_price * (1 + self.event_impact)\n\n        prices.append(new_price)\n\n    return prices\n</code></pre>"},{"location":"api/#discrete-event-simulations","title":"Discrete Event Simulations","text":""},{"location":"api/#discrete-event-simulation","title":"Discrete Event Simulation","text":""},{"location":"api/#sim_lab.core.DiscreteEventSimulation","title":"<code>sim_lab.core.DiscreteEventSimulation</code>","text":"<p>               Bases: <code>BaseSimulation</code></p> <p>A simulation class for discrete event simulations.</p> <p>This simulation processes events in chronological order, with each event potentially generating new events. The simulation runs until a specified end time or until there are no more events to process.</p> <p>Attributes:</p> Name Type Description <code>max_time</code> <code>float</code> <p>The maximum simulation time.</p> <code>days</code> <code>int</code> <p>Used for compatibility with other simulations (days = max_time).</p> <code>current_time</code> <code>float</code> <p>The current simulation time.</p> <code>event_queue</code> <code>List[Event]</code> <p>The priority queue of pending events.</p> <code>state</code> <code>Dict[str, Any]</code> <p>The current state of the simulation.</p> <code>results</code> <code>List[float]</code> <p>The results of the simulation at each time step.</p> <code>random_seed</code> <code>Optional[int]</code> <p>Seed for random number generation.</p> Source code in <code>src/sim_lab/core/discrete_event_simulation.py</code> <pre><code>@SimulatorRegistry.register(\"DiscreteEvent\")\nclass DiscreteEventSimulation(BaseSimulation):\n    \"\"\"A simulation class for discrete event simulations.\n\n    This simulation processes events in chronological order, with each event potentially\n    generating new events. The simulation runs until a specified end time or until\n    there are no more events to process.\n\n    Attributes:\n        max_time (float): The maximum simulation time.\n        days (int): Used for compatibility with other simulations (days = max_time).\n        current_time (float): The current simulation time.\n        event_queue (List[Event]): The priority queue of pending events.\n        state (Dict[str, Any]): The current state of the simulation.\n        results (List[float]): The results of the simulation at each time step.\n        random_seed (Optional[int]): Seed for random number generation.\n    \"\"\"\n\n    def __init__(\n        self, max_time: float, initial_events: List[Tuple[float, Callable, Any]] = None,\n        time_step: float = 1.0, random_seed: Optional[int] = None\n    ) -&gt; None:\n        \"\"\"Initialize the discrete event simulation.\n\n        Args:\n            max_time: The maximum simulation time.\n            initial_events: List of (time, action, data) tuples to initialize the event queue.\n            time_step: The time step for recording results (default: 1.0).\n            random_seed: Seed for random number generation.\n        \"\"\"\n        # Convert max_time to days for BaseSimulation compatibility\n        days = int(max_time)\n        super().__init__(days=days, random_seed=random_seed)\n\n        self.max_time = max_time\n        self.current_time = 0.0\n        self.event_queue = []\n        self.state = {\"value\": 0.0}  # Default state with a value field\n        self.results = [0.0]  # Start with initial value\n        self.time_step = time_step\n\n        # Schedule initial events\n        if initial_events:\n            for time, action, data in initial_events:\n                self.schedule_event(time, action, data=data)\n\n    def schedule_event(self, time: float, action: Callable, priority: int = 0, data: Any = None) -&gt; None:\n        \"\"\"Schedule a new event to occur at the specified time.\n\n        Args:\n            time: The absolute time at which the event should occur.\n            action: The function to execute when the event occurs.\n            priority: The priority of the event (lower is higher priority).\n            data: Additional data associated with the event.\n        \"\"\"\n        event = Event(time, action, priority, data)\n        heapq.heappush(self.event_queue, event)\n\n    def run_simulation(self) -&gt; List[float]:\n        \"\"\"Run the simulation until max_time or until there are no more events.\n\n        The simulation processes events in chronological order, with each event potentially\n        generating new events by calling schedule_event().\n\n        Returns:\n            A list of values representing the simulation state at regular intervals.\n        \"\"\"\n        # Reset the simulation\n        self.reset()\n\n        next_recording_time = self.time_step\n\n        # Process events until max_time or until there are no more events\n        while self.event_queue and self.current_time &lt; self.max_time:\n            # Get the next event\n            event = heapq.heappop(self.event_queue)\n\n            # Update the current time\n            self.current_time = event.time\n\n            # Record results at regular intervals\n            while next_recording_time &lt;= self.current_time and next_recording_time &lt;= self.max_time:\n                self.results.append(self.state[\"value\"])\n                next_recording_time += self.time_step\n\n            # Process the event if we haven't exceeded max_time\n            if self.current_time &lt;= self.max_time:\n                event.action(self, event.data)\n\n        # Make sure we have results for all time steps\n        while len(self.results) &lt;= self.days:\n            self.results.append(self.state[\"value\"])\n\n        return self.results\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset the simulation to its initial state.\"\"\"\n        super().reset()\n        self.current_time = 0.0\n        self.state = {\"value\": 0.0}\n        self.results = [0.0]\n\n    @classmethod\n    def get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n        \"\"\"Get information about the parameters required by this simulation.\n\n        Returns:\n            A dictionary mapping parameter names to their metadata.\n        \"\"\"\n        # Get base parameters from parent class\n        params = super().get_parameters_info()\n\n        # Replace 'days' with 'max_time'\n        del params['days']\n\n        # Add class-specific parameters\n        params.update({\n            'max_time': {\n                'type': 'float',\n                'description': 'The maximum simulation time',\n                'required': True\n            },\n            'initial_events': {\n                'type': 'List[Tuple[float, Callable, Any]]',\n                'description': 'List of (time, action, data) tuples to initialize the event queue',\n                'required': False,\n                'default': []\n            },\n            'time_step': {\n                'type': 'float',\n                'description': 'The time step for recording results',\n                'required': False,\n                'default': 1.0\n            }\n        })\n\n        return params\n</code></pre>"},{"location":"api/#sim_lab.core.DiscreteEventSimulation.__init__","title":"<code>__init__(max_time, initial_events=None, time_step=1.0, random_seed=None)</code>","text":"<p>Initialize the discrete event simulation.</p> <p>Parameters:</p> Name Type Description Default <code>max_time</code> <code>float</code> <p>The maximum simulation time.</p> required <code>initial_events</code> <code>List[Tuple[float, Callable, Any]]</code> <p>List of (time, action, data) tuples to initialize the event queue.</p> <code>None</code> <code>time_step</code> <code>float</code> <p>The time step for recording results (default: 1.0).</p> <code>1.0</code> <code>random_seed</code> <code>Optional[int]</code> <p>Seed for random number generation.</p> <code>None</code> Source code in <code>src/sim_lab/core/discrete_event_simulation.py</code> <pre><code>def __init__(\n    self, max_time: float, initial_events: List[Tuple[float, Callable, Any]] = None,\n    time_step: float = 1.0, random_seed: Optional[int] = None\n) -&gt; None:\n    \"\"\"Initialize the discrete event simulation.\n\n    Args:\n        max_time: The maximum simulation time.\n        initial_events: List of (time, action, data) tuples to initialize the event queue.\n        time_step: The time step for recording results (default: 1.0).\n        random_seed: Seed for random number generation.\n    \"\"\"\n    # Convert max_time to days for BaseSimulation compatibility\n    days = int(max_time)\n    super().__init__(days=days, random_seed=random_seed)\n\n    self.max_time = max_time\n    self.current_time = 0.0\n    self.event_queue = []\n    self.state = {\"value\": 0.0}  # Default state with a value field\n    self.results = [0.0]  # Start with initial value\n    self.time_step = time_step\n\n    # Schedule initial events\n    if initial_events:\n        for time, action, data in initial_events:\n            self.schedule_event(time, action, data=data)\n</code></pre>"},{"location":"api/#sim_lab.core.DiscreteEventSimulation.get_parameters_info","title":"<code>get_parameters_info()</code>  <code>classmethod</code>","text":"<p>Get information about the parameters required by this simulation.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Any]]</code> <p>A dictionary mapping parameter names to their metadata.</p> Source code in <code>src/sim_lab/core/discrete_event_simulation.py</code> <pre><code>@classmethod\ndef get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n    \"\"\"Get information about the parameters required by this simulation.\n\n    Returns:\n        A dictionary mapping parameter names to their metadata.\n    \"\"\"\n    # Get base parameters from parent class\n    params = super().get_parameters_info()\n\n    # Replace 'days' with 'max_time'\n    del params['days']\n\n    # Add class-specific parameters\n    params.update({\n        'max_time': {\n            'type': 'float',\n            'description': 'The maximum simulation time',\n            'required': True\n        },\n        'initial_events': {\n            'type': 'List[Tuple[float, Callable, Any]]',\n            'description': 'List of (time, action, data) tuples to initialize the event queue',\n            'required': False,\n            'default': []\n        },\n        'time_step': {\n            'type': 'float',\n            'description': 'The time step for recording results',\n            'required': False,\n            'default': 1.0\n        }\n    })\n\n    return params\n</code></pre>"},{"location":"api/#sim_lab.core.DiscreteEventSimulation.reset","title":"<code>reset()</code>","text":"<p>Reset the simulation to its initial state.</p> Source code in <code>src/sim_lab/core/discrete_event_simulation.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the simulation to its initial state.\"\"\"\n    super().reset()\n    self.current_time = 0.0\n    self.state = {\"value\": 0.0}\n    self.results = [0.0]\n</code></pre>"},{"location":"api/#sim_lab.core.DiscreteEventSimulation.run_simulation","title":"<code>run_simulation()</code>","text":"<p>Run the simulation until max_time or until there are no more events.</p> <p>The simulation processes events in chronological order, with each event potentially generating new events by calling schedule_event().</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>A list of values representing the simulation state at regular intervals.</p> Source code in <code>src/sim_lab/core/discrete_event_simulation.py</code> <pre><code>def run_simulation(self) -&gt; List[float]:\n    \"\"\"Run the simulation until max_time or until there are no more events.\n\n    The simulation processes events in chronological order, with each event potentially\n    generating new events by calling schedule_event().\n\n    Returns:\n        A list of values representing the simulation state at regular intervals.\n    \"\"\"\n    # Reset the simulation\n    self.reset()\n\n    next_recording_time = self.time_step\n\n    # Process events until max_time or until there are no more events\n    while self.event_queue and self.current_time &lt; self.max_time:\n        # Get the next event\n        event = heapq.heappop(self.event_queue)\n\n        # Update the current time\n        self.current_time = event.time\n\n        # Record results at regular intervals\n        while next_recording_time &lt;= self.current_time and next_recording_time &lt;= self.max_time:\n            self.results.append(self.state[\"value\"])\n            next_recording_time += self.time_step\n\n        # Process the event if we haven't exceeded max_time\n        if self.current_time &lt;= self.max_time:\n            event.action(self, event.data)\n\n    # Make sure we have results for all time steps\n    while len(self.results) &lt;= self.days:\n        self.results.append(self.state[\"value\"])\n\n    return self.results\n</code></pre>"},{"location":"api/#sim_lab.core.DiscreteEventSimulation.schedule_event","title":"<code>schedule_event(time, action, priority=0, data=None)</code>","text":"<p>Schedule a new event to occur at the specified time.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The absolute time at which the event should occur.</p> required <code>action</code> <code>Callable</code> <p>The function to execute when the event occurs.</p> required <code>priority</code> <code>int</code> <p>The priority of the event (lower is higher priority).</p> <code>0</code> <code>data</code> <code>Any</code> <p>Additional data associated with the event.</p> <code>None</code> Source code in <code>src/sim_lab/core/discrete_event_simulation.py</code> <pre><code>def schedule_event(self, time: float, action: Callable, priority: int = 0, data: Any = None) -&gt; None:\n    \"\"\"Schedule a new event to occur at the specified time.\n\n    Args:\n        time: The absolute time at which the event should occur.\n        action: The function to execute when the event occurs.\n        priority: The priority of the event (lower is higher priority).\n        data: Additional data associated with the event.\n    \"\"\"\n    event = Event(time, action, priority, data)\n    heapq.heappush(self.event_queue, event)\n</code></pre>"},{"location":"api/#advanced-simulation-types","title":"Advanced Simulation Types","text":""},{"location":"api/#agent-based-simulation","title":"Agent-Based Simulation","text":""},{"location":"api/#sim_lab.core.AgentBasedSimulation","title":"<code>sim_lab.core.AgentBasedSimulation</code>","text":"<p>               Bases: <code>BaseSimulation</code></p> <p>A simulation class for agent-based modeling.</p> <p>This simulation models complex systems by simulating the actions and interactions of autonomous agents, allowing for emergent behavior to be observed.</p> <p>Attributes:</p> Name Type Description <code>agents</code> <code>List[Agent]</code> <p>List of agents in the simulation.</p> <code>environment</code> <code>Environment</code> <p>The environment in which agents operate.</p> <code>days</code> <code>int</code> <p>Number of steps to simulate.</p> <code>neighborhood_radius</code> <code>float</code> <p>Radius for determining agent neighbors.</p> <code>random_seed</code> <code>Optional[int]</code> <p>Seed for random number generation.</p> Source code in <code>src/sim_lab/core/agent_based_simulation.py</code> <pre><code>@SimulatorRegistry.register(\"AgentBased\")\nclass AgentBasedSimulation(BaseSimulation):\n    \"\"\"A simulation class for agent-based modeling.\n\n    This simulation models complex systems by simulating the actions and interactions\n    of autonomous agents, allowing for emergent behavior to be observed.\n\n    Attributes:\n        agents (List[Agent]): List of agents in the simulation.\n        environment (Environment): The environment in which agents operate.\n        days (int): Number of steps to simulate.\n        neighborhood_radius (float): Radius for determining agent neighbors.\n        random_seed (Optional[int]): Seed for random number generation.\n    \"\"\"\n\n    def __init__(\n        self,\n        agent_factory: Callable[[int], Agent],\n        num_agents: int,\n        environment: Optional[Environment] = None,\n        days: int = 100,\n        neighborhood_radius: float = 10.0,\n        save_history: bool = False,\n        random_seed: Optional[int] = None\n    ) -&gt; None:\n        \"\"\"Initialize the agent-based simulation.\n\n        Args:\n            agent_factory: Function that creates new agents with given IDs.\n            num_agents: Number of agents to create.\n            environment: The environment in which agents operate. If None, a default environment is created.\n            days: Number of steps to simulate.\n            neighborhood_radius: Radius for determining agent neighbors.\n            save_history: Whether to save agent and environment history.\n            random_seed: Seed for random number generation.\n        \"\"\"\n        super().__init__(days=days, random_seed=random_seed)\n\n        self.environment = environment or Environment()\n        self.neighborhood_radius = neighborhood_radius\n        self.save_history = save_history\n\n        # Create agents\n        self.agents = [agent_factory(i) for i in range(num_agents)]\n\n        # Initialize tracking variables\n        self.metrics = []\n\n    def get_agent_neighbors(self, agent: Agent) -&gt; List[Agent]:\n        \"\"\"Get the neighbors of an agent based on proximity.\n\n        Args:\n            agent: The agent whose neighbors to find.\n\n        Returns:\n            List of neighboring agents within the neighborhood radius.\n        \"\"\"\n        if agent.position is None:\n            return []  # No position, no neighbors\n\n        neighbors = []\n        for other in self.agents:\n            if other.agent_id == agent.agent_id or other.position is None:\n                continue  # Skip self and agents without position\n\n            # Calculate Euclidean distance\n            dx = agent.position[0] - other.position[0]\n            dy = agent.position[1] - other.position[1]\n            distance = (dx**2 + dy**2)**0.5\n\n            if distance &lt;= self.neighborhood_radius:\n                neighbors.append(other)\n\n        return neighbors\n\n    def calculate_metrics(self) -&gt; Dict[str, Any]:\n        \"\"\"Calculate metrics for the current simulation state.\n\n        Override this method to define specific metrics for your simulation.\n\n        Returns:\n            Dictionary of metrics derived from agent and environment states.\n        \"\"\"\n        # Default implementation: count agents in different states\n        state_counts = {}\n\n        for agent in self.agents:\n            for key, value in agent.state.items():\n                if isinstance(value, (bool, int, str, float)):\n                    state_key = f\"{key}_{value}\"\n                    state_counts[state_key] = state_counts.get(state_key, 0) + 1\n\n        return state_counts\n\n    def run_simulation(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Run the agent-based simulation.\n\n        Returns:\n            A list of metrics dictionaries for each time step.\n        \"\"\"\n        self.reset()\n\n        # Initialize history if tracking\n        if self.save_history:\n            for agent in self.agents:\n                agent.reset()\n                agent.save_history()\n            self.environment.reset()\n            self.environment.save_history()\n\n        # Calculate initial metrics\n        self.metrics = [self.calculate_metrics()]\n\n        # Run for specified number of days\n        for _ in range(1, self.days):\n            # Update agents\n            for agent in self.agents:\n                neighbors = self.get_agent_neighbors(agent)\n                agent.update(self.environment, neighbors)\n\n                if self.save_history:\n                    agent.save_history()\n\n            # Update environment\n            self.environment.update(self.agents)\n\n            if self.save_history:\n                self.environment.save_history()\n\n            # Calculate metrics\n            self.metrics.append(self.calculate_metrics())\n\n        return self.metrics\n\n    def get_agent_history(self, agent_id: int) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get the state history for a specific agent.\n\n        Args:\n            agent_id: The ID of the agent.\n\n        Returns:\n            List of state dictionaries representing the agent's history.\n        \"\"\"\n        if not self.save_history:\n            raise ValueError(\"Agent history was not saved. Set save_history=True when creating the simulation.\")\n\n        for agent in self.agents:\n            if agent.agent_id == agent_id:\n                return agent.history\n\n        raise ValueError(f\"No agent with ID {agent_id} found\")\n\n    def get_environment_history(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Get the environment state history.\n\n        Returns:\n            List of state dictionaries representing the environment's history.\n        \"\"\"\n        if not self.save_history:\n            raise ValueError(\"Environment history was not saved. Set save_history=True when creating the simulation.\")\n\n        return self.environment.history\n\n    def get_metric_history(self, metric_name: str) -&gt; List[Any]:\n        \"\"\"Get the history of a specific metric.\n\n        Args:\n            metric_name: The name of the metric to retrieve.\n\n        Returns:\n            List of values for the specified metric over time.\n        \"\"\"\n        if not self.metrics:\n            raise ValueError(\"No simulation results available. Run the simulation first.\")\n\n        try:\n            return [metrics[metric_name] for metrics in self.metrics]\n        except KeyError:\n            raise ValueError(f\"Metric '{metric_name}' not found in simulation results\")\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset the simulation to its initial state.\"\"\"\n        super().reset()\n        self.metrics = []\n\n    @classmethod\n    def get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n        \"\"\"Get information about the parameters required by this simulation.\n\n        Returns:\n            A dictionary mapping parameter names to their metadata.\n        \"\"\"\n        # Get base parameters from parent class\n        params = super().get_parameters_info()\n\n        # Add class-specific parameters\n        params.update({\n            'agent_factory': {\n                'type': 'Callable[[int], Agent]',\n                'description': 'Function that creates new agents with given IDs',\n                'required': True\n            },\n            'num_agents': {\n                'type': 'int',\n                'description': 'Number of agents to create',\n                'required': True\n            },\n            'environment': {\n                'type': 'Environment',\n                'description': 'The environment in which agents operate',\n                'required': False,\n                'default': 'Default Environment'\n            },\n            'neighborhood_radius': {\n                'type': 'float',\n                'description': 'Radius for determining agent neighbors',\n                'required': False,\n                'default': 10.0\n            },\n            'save_history': {\n                'type': 'bool',\n                'description': 'Whether to save agent and environment history',\n                'required': False,\n                'default': False\n            }\n        })\n\n        return params\n</code></pre>"},{"location":"api/#sim_lab.core.AgentBasedSimulation.__init__","title":"<code>__init__(agent_factory, num_agents, environment=None, days=100, neighborhood_radius=10.0, save_history=False, random_seed=None)</code>","text":"<p>Initialize the agent-based simulation.</p> <p>Parameters:</p> Name Type Description Default <code>agent_factory</code> <code>Callable[[int], Agent]</code> <p>Function that creates new agents with given IDs.</p> required <code>num_agents</code> <code>int</code> <p>Number of agents to create.</p> required <code>environment</code> <code>Optional[Environment]</code> <p>The environment in which agents operate. If None, a default environment is created.</p> <code>None</code> <code>days</code> <code>int</code> <p>Number of steps to simulate.</p> <code>100</code> <code>neighborhood_radius</code> <code>float</code> <p>Radius for determining agent neighbors.</p> <code>10.0</code> <code>save_history</code> <code>bool</code> <p>Whether to save agent and environment history.</p> <code>False</code> <code>random_seed</code> <code>Optional[int]</code> <p>Seed for random number generation.</p> <code>None</code> Source code in <code>src/sim_lab/core/agent_based_simulation.py</code> <pre><code>def __init__(\n    self,\n    agent_factory: Callable[[int], Agent],\n    num_agents: int,\n    environment: Optional[Environment] = None,\n    days: int = 100,\n    neighborhood_radius: float = 10.0,\n    save_history: bool = False,\n    random_seed: Optional[int] = None\n) -&gt; None:\n    \"\"\"Initialize the agent-based simulation.\n\n    Args:\n        agent_factory: Function that creates new agents with given IDs.\n        num_agents: Number of agents to create.\n        environment: The environment in which agents operate. If None, a default environment is created.\n        days: Number of steps to simulate.\n        neighborhood_radius: Radius for determining agent neighbors.\n        save_history: Whether to save agent and environment history.\n        random_seed: Seed for random number generation.\n    \"\"\"\n    super().__init__(days=days, random_seed=random_seed)\n\n    self.environment = environment or Environment()\n    self.neighborhood_radius = neighborhood_radius\n    self.save_history = save_history\n\n    # Create agents\n    self.agents = [agent_factory(i) for i in range(num_agents)]\n\n    # Initialize tracking variables\n    self.metrics = []\n</code></pre>"},{"location":"api/#sim_lab.core.AgentBasedSimulation.calculate_metrics","title":"<code>calculate_metrics()</code>","text":"<p>Calculate metrics for the current simulation state.</p> <p>Override this method to define specific metrics for your simulation.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of metrics derived from agent and environment states.</p> Source code in <code>src/sim_lab/core/agent_based_simulation.py</code> <pre><code>def calculate_metrics(self) -&gt; Dict[str, Any]:\n    \"\"\"Calculate metrics for the current simulation state.\n\n    Override this method to define specific metrics for your simulation.\n\n    Returns:\n        Dictionary of metrics derived from agent and environment states.\n    \"\"\"\n    # Default implementation: count agents in different states\n    state_counts = {}\n\n    for agent in self.agents:\n        for key, value in agent.state.items():\n            if isinstance(value, (bool, int, str, float)):\n                state_key = f\"{key}_{value}\"\n                state_counts[state_key] = state_counts.get(state_key, 0) + 1\n\n    return state_counts\n</code></pre>"},{"location":"api/#sim_lab.core.AgentBasedSimulation.get_agent_history","title":"<code>get_agent_history(agent_id)</code>","text":"<p>Get the state history for a specific agent.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>int</code> <p>The ID of the agent.</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of state dictionaries representing the agent's history.</p> Source code in <code>src/sim_lab/core/agent_based_simulation.py</code> <pre><code>def get_agent_history(self, agent_id: int) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get the state history for a specific agent.\n\n    Args:\n        agent_id: The ID of the agent.\n\n    Returns:\n        List of state dictionaries representing the agent's history.\n    \"\"\"\n    if not self.save_history:\n        raise ValueError(\"Agent history was not saved. Set save_history=True when creating the simulation.\")\n\n    for agent in self.agents:\n        if agent.agent_id == agent_id:\n            return agent.history\n\n    raise ValueError(f\"No agent with ID {agent_id} found\")\n</code></pre>"},{"location":"api/#sim_lab.core.AgentBasedSimulation.get_agent_neighbors","title":"<code>get_agent_neighbors(agent)</code>","text":"<p>Get the neighbors of an agent based on proximity.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Agent</code> <p>The agent whose neighbors to find.</p> required <p>Returns:</p> Type Description <code>List[Agent]</code> <p>List of neighboring agents within the neighborhood radius.</p> Source code in <code>src/sim_lab/core/agent_based_simulation.py</code> <pre><code>def get_agent_neighbors(self, agent: Agent) -&gt; List[Agent]:\n    \"\"\"Get the neighbors of an agent based on proximity.\n\n    Args:\n        agent: The agent whose neighbors to find.\n\n    Returns:\n        List of neighboring agents within the neighborhood radius.\n    \"\"\"\n    if agent.position is None:\n        return []  # No position, no neighbors\n\n    neighbors = []\n    for other in self.agents:\n        if other.agent_id == agent.agent_id or other.position is None:\n            continue  # Skip self and agents without position\n\n        # Calculate Euclidean distance\n        dx = agent.position[0] - other.position[0]\n        dy = agent.position[1] - other.position[1]\n        distance = (dx**2 + dy**2)**0.5\n\n        if distance &lt;= self.neighborhood_radius:\n            neighbors.append(other)\n\n    return neighbors\n</code></pre>"},{"location":"api/#sim_lab.core.AgentBasedSimulation.get_environment_history","title":"<code>get_environment_history()</code>","text":"<p>Get the environment state history.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of state dictionaries representing the environment's history.</p> Source code in <code>src/sim_lab/core/agent_based_simulation.py</code> <pre><code>def get_environment_history(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get the environment state history.\n\n    Returns:\n        List of state dictionaries representing the environment's history.\n    \"\"\"\n    if not self.save_history:\n        raise ValueError(\"Environment history was not saved. Set save_history=True when creating the simulation.\")\n\n    return self.environment.history\n</code></pre>"},{"location":"api/#sim_lab.core.AgentBasedSimulation.get_metric_history","title":"<code>get_metric_history(metric_name)</code>","text":"<p>Get the history of a specific metric.</p> <p>Parameters:</p> Name Type Description Default <code>metric_name</code> <code>str</code> <p>The name of the metric to retrieve.</p> required <p>Returns:</p> Type Description <code>List[Any]</code> <p>List of values for the specified metric over time.</p> Source code in <code>src/sim_lab/core/agent_based_simulation.py</code> <pre><code>def get_metric_history(self, metric_name: str) -&gt; List[Any]:\n    \"\"\"Get the history of a specific metric.\n\n    Args:\n        metric_name: The name of the metric to retrieve.\n\n    Returns:\n        List of values for the specified metric over time.\n    \"\"\"\n    if not self.metrics:\n        raise ValueError(\"No simulation results available. Run the simulation first.\")\n\n    try:\n        return [metrics[metric_name] for metrics in self.metrics]\n    except KeyError:\n        raise ValueError(f\"Metric '{metric_name}' not found in simulation results\")\n</code></pre>"},{"location":"api/#sim_lab.core.AgentBasedSimulation.get_parameters_info","title":"<code>get_parameters_info()</code>  <code>classmethod</code>","text":"<p>Get information about the parameters required by this simulation.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Any]]</code> <p>A dictionary mapping parameter names to their metadata.</p> Source code in <code>src/sim_lab/core/agent_based_simulation.py</code> <pre><code>@classmethod\ndef get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n    \"\"\"Get information about the parameters required by this simulation.\n\n    Returns:\n        A dictionary mapping parameter names to their metadata.\n    \"\"\"\n    # Get base parameters from parent class\n    params = super().get_parameters_info()\n\n    # Add class-specific parameters\n    params.update({\n        'agent_factory': {\n            'type': 'Callable[[int], Agent]',\n            'description': 'Function that creates new agents with given IDs',\n            'required': True\n        },\n        'num_agents': {\n            'type': 'int',\n            'description': 'Number of agents to create',\n            'required': True\n        },\n        'environment': {\n            'type': 'Environment',\n            'description': 'The environment in which agents operate',\n            'required': False,\n            'default': 'Default Environment'\n        },\n        'neighborhood_radius': {\n            'type': 'float',\n            'description': 'Radius for determining agent neighbors',\n            'required': False,\n            'default': 10.0\n        },\n        'save_history': {\n            'type': 'bool',\n            'description': 'Whether to save agent and environment history',\n            'required': False,\n            'default': False\n        }\n    })\n\n    return params\n</code></pre>"},{"location":"api/#sim_lab.core.AgentBasedSimulation.reset","title":"<code>reset()</code>","text":"<p>Reset the simulation to its initial state.</p> Source code in <code>src/sim_lab/core/agent_based_simulation.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the simulation to its initial state.\"\"\"\n    super().reset()\n    self.metrics = []\n</code></pre>"},{"location":"api/#sim_lab.core.AgentBasedSimulation.run_simulation","title":"<code>run_simulation()</code>","text":"<p>Run the agent-based simulation.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>A list of metrics dictionaries for each time step.</p> Source code in <code>src/sim_lab/core/agent_based_simulation.py</code> <pre><code>def run_simulation(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Run the agent-based simulation.\n\n    Returns:\n        A list of metrics dictionaries for each time step.\n    \"\"\"\n    self.reset()\n\n    # Initialize history if tracking\n    if self.save_history:\n        for agent in self.agents:\n            agent.reset()\n            agent.save_history()\n        self.environment.reset()\n        self.environment.save_history()\n\n    # Calculate initial metrics\n    self.metrics = [self.calculate_metrics()]\n\n    # Run for specified number of days\n    for _ in range(1, self.days):\n        # Update agents\n        for agent in self.agents:\n            neighbors = self.get_agent_neighbors(agent)\n            agent.update(self.environment, neighbors)\n\n            if self.save_history:\n                agent.save_history()\n\n        # Update environment\n        self.environment.update(self.agents)\n\n        if self.save_history:\n            self.environment.save_history()\n\n        # Calculate metrics\n        self.metrics.append(self.calculate_metrics())\n\n    return self.metrics\n</code></pre>"},{"location":"api/#network-simulation","title":"Network Simulation","text":""},{"location":"api/#sim_lab.core.NetworkSimulation","title":"<code>sim_lab.core.NetworkSimulation</code>","text":"<p>               Bases: <code>BaseSimulation</code></p> <p>A simulation class for network/graph dynamics.</p> <p>This simulation models the evolution of a network over time, allowing for changes  in node and edge attributes, as well as network structure.</p> <p>Attributes:</p> Name Type Description <code>nodes</code> <code>Dict[Any, Node]</code> <p>Dictionary of nodes in the network.</p> <code>edges</code> <code>List[Edge]</code> <p>List of edges in the network.</p> <code>days</code> <code>int</code> <p>Number of steps to simulate.</p> <code>update_function</code> <code>Callable</code> <p>Function to update the network at each time step.</p> <code>save_history</code> <code>bool</code> <p>Whether to save node and edge history.</p> <code>random_seed</code> <code>Optional[int]</code> <p>Seed for random number generation.</p> Source code in <code>src/sim_lab/core/network_simulation.py</code> <pre><code>@SimulatorRegistry.register(\"Network\")\nclass NetworkSimulation(BaseSimulation):\n    \"\"\"A simulation class for network/graph dynamics.\n\n    This simulation models the evolution of a network over time, allowing for changes \n    in node and edge attributes, as well as network structure.\n\n    Attributes:\n        nodes (Dict[Any, Node]): Dictionary of nodes in the network.\n        edges (List[Edge]): List of edges in the network.\n        days (int): Number of steps to simulate.\n        update_function (Callable): Function to update the network at each time step.\n        save_history (bool): Whether to save node and edge history.\n        random_seed (Optional[int]): Seed for random number generation.\n    \"\"\"\n\n    def __init__(\n        self,\n        initial_nodes: Optional[Dict[Any, Dict[str, Any]]] = None,\n        initial_edges: Optional[List[Tuple[Any, Any, Dict[str, Any]]]] = None,\n        update_function: Optional[Callable] = None,\n        directed: bool = False,\n        days: int = 100,\n        save_history: bool = False,\n        random_seed: Optional[int] = None\n    ) -&gt; None:\n        \"\"\"Initialize the network simulation.\n\n        Args:\n            initial_nodes: Dictionary mapping node IDs to attribute dictionaries.\n            initial_edges: List of (source, target, attributes) tuples.\n            update_function: Function that updates the network at each time step.\n            directed: Whether the network is directed.\n            days: Number of steps to simulate.\n            save_history: Whether to save node and edge history.\n            random_seed: Seed for random number generation.\n        \"\"\"\n        super().__init__(days=days, random_seed=random_seed)\n\n        self.directed = directed\n        self.save_history = save_history\n        self.update_function = update_function or (lambda network, day: None)\n\n        # Initialize nodes\n        self.nodes = {}\n        if initial_nodes:\n            for node_id, attributes in initial_nodes.items():\n                self.add_node(node_id, attributes)\n\n        # Initialize edges\n        self.edges = []\n        if initial_edges:\n            for source, target, attributes in initial_edges:\n                weight = attributes.pop('weight', 1.0) if attributes else 1.0\n                self.add_edge(source, target, directed, weight, attributes)\n\n        # Initialize metrics tracking\n        self.metrics = {}\n\n    def add_node(self, node_id: Any, attributes: Optional[Dict[str, Any]] = None) -&gt; Node:\n        \"\"\"Add a node to the network.\n\n        Args:\n            node_id: Unique identifier for the node.\n            attributes: Dictionary of node attributes.\n\n        Returns:\n            The created node.\n\n        Raises:\n            ValueError: If a node with the given ID already exists.\n        \"\"\"\n        if node_id in self.nodes:\n            raise ValueError(f\"Node with ID {node_id} already exists\")\n\n        node = Node(node_id, attributes)\n        self.nodes[node_id] = node\n        return node\n\n    def remove_node(self, node_id: Any) -&gt; None:\n        \"\"\"Remove a node from the network.\n\n        Args:\n            node_id: The ID of the node to remove.\n\n        Raises:\n            ValueError: If the node doesn't exist.\n        \"\"\"\n        if node_id not in self.nodes:\n            raise ValueError(f\"Node with ID {node_id} doesn't exist\")\n\n        # Remove edges connected to this node\n        self.edges = [edge for edge in self.edges if edge.source != node_id and edge.target != node_id]\n\n        # Remove node from neighbor lists\n        for node in self.nodes.values():\n            if node_id in node.neighbors:\n                node.neighbors.remove(node_id)\n\n        # Remove the node\n        del self.nodes[node_id]\n\n    def add_edge(\n        self,\n        source: Any,\n        target: Any,\n        directed: Optional[bool] = None,\n        weight: float = 1.0,\n        attributes: Optional[Dict[str, Any]] = None\n    ) -&gt; Edge:\n        \"\"\"Add an edge to the network.\n\n        Args:\n            source: Source node ID.\n            target: Target node ID.\n            directed: Whether the edge is directed (defaults to network's directed attribute).\n            weight: Edge weight.\n            attributes: Dictionary of edge attributes.\n\n        Returns:\n            The created edge.\n\n        Raises:\n            ValueError: If the source or target node doesn't exist.\n        \"\"\"\n        if source not in self.nodes:\n            raise ValueError(f\"Source node with ID {source} doesn't exist\")\n        if target not in self.nodes:\n            raise ValueError(f\"Target node with ID {target} doesn't exist\")\n\n        # Use network's directed attribute if not specified\n        if directed is None:\n            directed = self.directed\n\n        # Create the edge\n        edge = Edge(source, target, directed, weight, attributes)\n        self.edges.append(edge)\n\n        # Update node neighbor lists\n        self.nodes[source].add_neighbor(target)\n        if not directed:\n            self.nodes[target].add_neighbor(source)\n\n        return edge\n\n    def remove_edge(self, source: Any, target: Any) -&gt; None:\n        \"\"\"Remove an edge from the network.\n\n        Args:\n            source: Source node ID.\n            target: Target node ID.\n\n        Raises:\n            ValueError: If the edge doesn't exist.\n        \"\"\"\n        # Find the edge\n        for i, edge in enumerate(self.edges):\n            if edge.source == source and edge.target == target:\n                # Remove from neighbor lists\n                self.nodes[source].remove_neighbor(target)\n                if not edge.directed:\n                    self.nodes[target].remove_neighbor(source)\n\n                # Remove the edge\n                self.edges.pop(i)\n                return\n\n        # Check for undirected edge in reverse direction\n        if not self.directed:\n            for i, edge in enumerate(self.edges):\n                if edge.source == target and edge.target == source:\n                    # Remove from neighbor lists\n                    self.nodes[target].remove_neighbor(source)\n                    self.nodes[source].remove_neighbor(target)\n\n                    # Remove the edge\n                    self.edges.pop(i)\n                    return\n\n        raise ValueError(f\"Edge from {source} to {target} doesn't exist\")\n\n    def get_adjacency_matrix(self) -&gt; np.ndarray:\n        \"\"\"Get the adjacency matrix of the network.\n\n        Returns:\n            A NumPy array representing the adjacency matrix, with weights if applicable.\n        \"\"\"\n        # Create a mapping from node IDs to indices\n        node_ids = list(self.nodes.keys())\n        node_to_index = {node_id: i for i, node_id in enumerate(node_ids)}\n\n        # Initialize the adjacency matrix\n        n = len(node_ids)\n        adj_matrix = np.zeros((n, n))\n\n        # Fill in the adjacency matrix\n        for edge in self.edges:\n            i = node_to_index[edge.source]\n            j = node_to_index[edge.target]\n            adj_matrix[i, j] = edge.weight\n            if not edge.directed:\n                adj_matrix[j, i] = edge.weight\n\n        return adj_matrix\n\n    def get_degree_distribution(self) -&gt; Dict[int, int]:\n        \"\"\"Get the degree distribution of the network.\n\n        Returns:\n            A dictionary mapping degrees to the number of nodes with that degree.\n        \"\"\"\n        degrees = [len(node.neighbors) for node in self.nodes.values()]\n        degree_counts = {}\n        for degree in degrees:\n            degree_counts[degree] = degree_counts.get(degree, 0) + 1\n        return degree_counts\n\n    def calculate_metrics(self) -&gt; Dict[str, Any]:\n        \"\"\"Calculate metrics for the current network state.\n\n        Returns:\n            A dictionary of network metrics.\n        \"\"\"\n        # Number of nodes and edges\n        num_nodes = len(self.nodes)\n        num_edges = len(self.edges)\n\n        # Average degree\n        total_degree = sum(len(node.neighbors) for node in self.nodes.values())\n        avg_degree = total_degree / num_nodes if num_nodes &gt; 0 else 0\n\n        # Density (ratio of actual to possible edges)\n        possible_edges = num_nodes * (num_nodes - 1)\n        if self.directed:\n            density = num_edges / possible_edges if possible_edges &gt; 0 else 0\n        else:\n            density = 2 * num_edges / possible_edges if possible_edges &gt; 0 else 0\n\n        # Result dictionary\n        metrics = {\n            'num_nodes': num_nodes,\n            'num_edges': num_edges,\n            'avg_degree': avg_degree,\n            'density': density\n        }\n\n        return metrics\n\n    def run_simulation(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"Run the network simulation.\n\n        In each step, the network is updated according to the update function.\n\n        Returns:\n            A list of dictionaries containing network metrics for each time step.\n        \"\"\"\n        self.reset()\n\n        # Initialize history if tracking\n        if self.save_history:\n            for node in self.nodes.values():\n                node.history = [node.attributes.copy()]\n\n            for edge in self.edges:\n                state = edge.attributes.copy()\n                state['weight'] = edge.weight\n                edge.history = [state]\n\n        # Calculate initial metrics\n        self.metrics = [self.calculate_metrics()]\n\n        # Run for specified number of days\n        for day in range(1, self.days):\n            # Update the network\n            self.update_function(self, day)\n\n            # Save history if tracking\n            if self.save_history:\n                for node in self.nodes.values():\n                    node.save_history()\n\n                for edge in self.edges:\n                    edge.save_history()\n\n            # Calculate metrics\n            self.metrics.append(self.calculate_metrics())\n\n        return self.metrics\n\n    def get_node_attribute_history(self, node_id: Any, attribute: str) -&gt; List[Any]:\n        \"\"\"Get the history of a specific node attribute.\n\n        Args:\n            node_id: The ID of the node.\n            attribute: The name of the attribute.\n\n        Returns:\n            List of values for the attribute over time.\n\n        Raises:\n            ValueError: If the node doesn't exist or history wasn't saved.\n        \"\"\"\n        if not self.save_history:\n            raise ValueError(\"Node history wasn't saved. Set save_history=True when creating the simulation.\")\n\n        if node_id not in self.nodes:\n            raise ValueError(f\"Node with ID {node_id} doesn't exist\")\n\n        return self.nodes[node_id].get_attribute_history(attribute)\n\n    def get_edge_attribute_history(self, source: Any, target: Any, attribute: str) -&gt; List[Any]:\n        \"\"\"Get the history of a specific edge attribute.\n\n        Args:\n            source: Source node ID.\n            target: Target node ID.\n            attribute: The name of the attribute.\n\n        Returns:\n            List of values for the attribute over time.\n\n        Raises:\n            ValueError: If the edge doesn't exist or history wasn't saved.\n        \"\"\"\n        if not self.save_history:\n            raise ValueError(\"Edge history wasn't saved. Set save_history=True when creating the simulation.\")\n\n        # Find the edge\n        for edge in self.edges:\n            if edge.source == source and edge.target == target:\n                return edge.get_attribute_history(attribute)\n\n        # Check for undirected edge in reverse direction\n        if not self.directed:\n            for edge in self.edges:\n                if edge.source == target and edge.target == source:\n                    return edge.get_attribute_history(attribute)\n\n        raise ValueError(f\"Edge from {source} to {target} doesn't exist\")\n\n    def reset(self) -&gt; None:\n        \"\"\"Reset the simulation to its initial state.\"\"\"\n        super().reset()\n\n        # Clear metrics\n        self.metrics = []\n\n        # Clear node and edge history\n        if self.save_history:\n            for node in self.nodes.values():\n                node.history = [node.attributes.copy()]\n\n            for edge in self.edges:\n                state = edge.attributes.copy()\n                state['weight'] = edge.weight\n                edge.history = [state]\n\n    @classmethod\n    def get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n        \"\"\"Get information about the parameters required by this simulation.\n\n        Returns:\n            A dictionary mapping parameter names to their metadata.\n        \"\"\"\n        # Get base parameters from parent class\n        params = super().get_parameters_info()\n\n        # Add class-specific parameters\n        params.update({\n            'initial_nodes': {\n                'type': 'Dict[Any, Dict[str, Any]]',\n                'description': 'Dictionary mapping node IDs to attribute dictionaries',\n                'required': False,\n                'default': '{}'\n            },\n            'initial_edges': {\n                'type': 'List[Tuple[Any, Any, Dict[str, Any]]]',\n                'description': 'List of (source, target, attributes) tuples',\n                'required': False,\n                'default': '[]'\n            },\n            'update_function': {\n                'type': 'Callable',\n                'description': 'Function that updates the network at each time step',\n                'required': False,\n                'default': 'None'\n            },\n            'directed': {\n                'type': 'bool',\n                'description': 'Whether the network is directed',\n                'required': False,\n                'default': 'False'\n            },\n            'save_history': {\n                'type': 'bool',\n                'description': 'Whether to save node and edge history',\n                'required': False,\n                'default': 'False'\n            }\n        })\n\n        return params\n</code></pre>"},{"location":"api/#sim_lab.core.NetworkSimulation.__init__","title":"<code>__init__(initial_nodes=None, initial_edges=None, update_function=None, directed=False, days=100, save_history=False, random_seed=None)</code>","text":"<p>Initialize the network simulation.</p> <p>Parameters:</p> Name Type Description Default <code>initial_nodes</code> <code>Optional[Dict[Any, Dict[str, Any]]]</code> <p>Dictionary mapping node IDs to attribute dictionaries.</p> <code>None</code> <code>initial_edges</code> <code>Optional[List[Tuple[Any, Any, Dict[str, Any]]]]</code> <p>List of (source, target, attributes) tuples.</p> <code>None</code> <code>update_function</code> <code>Optional[Callable]</code> <p>Function that updates the network at each time step.</p> <code>None</code> <code>directed</code> <code>bool</code> <p>Whether the network is directed.</p> <code>False</code> <code>days</code> <code>int</code> <p>Number of steps to simulate.</p> <code>100</code> <code>save_history</code> <code>bool</code> <p>Whether to save node and edge history.</p> <code>False</code> <code>random_seed</code> <code>Optional[int]</code> <p>Seed for random number generation.</p> <code>None</code> Source code in <code>src/sim_lab/core/network_simulation.py</code> <pre><code>def __init__(\n    self,\n    initial_nodes: Optional[Dict[Any, Dict[str, Any]]] = None,\n    initial_edges: Optional[List[Tuple[Any, Any, Dict[str, Any]]]] = None,\n    update_function: Optional[Callable] = None,\n    directed: bool = False,\n    days: int = 100,\n    save_history: bool = False,\n    random_seed: Optional[int] = None\n) -&gt; None:\n    \"\"\"Initialize the network simulation.\n\n    Args:\n        initial_nodes: Dictionary mapping node IDs to attribute dictionaries.\n        initial_edges: List of (source, target, attributes) tuples.\n        update_function: Function that updates the network at each time step.\n        directed: Whether the network is directed.\n        days: Number of steps to simulate.\n        save_history: Whether to save node and edge history.\n        random_seed: Seed for random number generation.\n    \"\"\"\n    super().__init__(days=days, random_seed=random_seed)\n\n    self.directed = directed\n    self.save_history = save_history\n    self.update_function = update_function or (lambda network, day: None)\n\n    # Initialize nodes\n    self.nodes = {}\n    if initial_nodes:\n        for node_id, attributes in initial_nodes.items():\n            self.add_node(node_id, attributes)\n\n    # Initialize edges\n    self.edges = []\n    if initial_edges:\n        for source, target, attributes in initial_edges:\n            weight = attributes.pop('weight', 1.0) if attributes else 1.0\n            self.add_edge(source, target, directed, weight, attributes)\n\n    # Initialize metrics tracking\n    self.metrics = {}\n</code></pre>"},{"location":"api/#sim_lab.core.NetworkSimulation.add_edge","title":"<code>add_edge(source, target, directed=None, weight=1.0, attributes=None)</code>","text":"<p>Add an edge to the network.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Any</code> <p>Source node ID.</p> required <code>target</code> <code>Any</code> <p>Target node ID.</p> required <code>directed</code> <code>Optional[bool]</code> <p>Whether the edge is directed (defaults to network's directed attribute).</p> <code>None</code> <code>weight</code> <code>float</code> <p>Edge weight.</p> <code>1.0</code> <code>attributes</code> <code>Optional[Dict[str, Any]]</code> <p>Dictionary of edge attributes.</p> <code>None</code> <p>Returns:</p> Type Description <code>Edge</code> <p>The created edge.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the source or target node doesn't exist.</p> Source code in <code>src/sim_lab/core/network_simulation.py</code> <pre><code>def add_edge(\n    self,\n    source: Any,\n    target: Any,\n    directed: Optional[bool] = None,\n    weight: float = 1.0,\n    attributes: Optional[Dict[str, Any]] = None\n) -&gt; Edge:\n    \"\"\"Add an edge to the network.\n\n    Args:\n        source: Source node ID.\n        target: Target node ID.\n        directed: Whether the edge is directed (defaults to network's directed attribute).\n        weight: Edge weight.\n        attributes: Dictionary of edge attributes.\n\n    Returns:\n        The created edge.\n\n    Raises:\n        ValueError: If the source or target node doesn't exist.\n    \"\"\"\n    if source not in self.nodes:\n        raise ValueError(f\"Source node with ID {source} doesn't exist\")\n    if target not in self.nodes:\n        raise ValueError(f\"Target node with ID {target} doesn't exist\")\n\n    # Use network's directed attribute if not specified\n    if directed is None:\n        directed = self.directed\n\n    # Create the edge\n    edge = Edge(source, target, directed, weight, attributes)\n    self.edges.append(edge)\n\n    # Update node neighbor lists\n    self.nodes[source].add_neighbor(target)\n    if not directed:\n        self.nodes[target].add_neighbor(source)\n\n    return edge\n</code></pre>"},{"location":"api/#sim_lab.core.NetworkSimulation.add_node","title":"<code>add_node(node_id, attributes=None)</code>","text":"<p>Add a node to the network.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>Any</code> <p>Unique identifier for the node.</p> required <code>attributes</code> <code>Optional[Dict[str, Any]]</code> <p>Dictionary of node attributes.</p> <code>None</code> <p>Returns:</p> Type Description <code>Node</code> <p>The created node.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a node with the given ID already exists.</p> Source code in <code>src/sim_lab/core/network_simulation.py</code> <pre><code>def add_node(self, node_id: Any, attributes: Optional[Dict[str, Any]] = None) -&gt; Node:\n    \"\"\"Add a node to the network.\n\n    Args:\n        node_id: Unique identifier for the node.\n        attributes: Dictionary of node attributes.\n\n    Returns:\n        The created node.\n\n    Raises:\n        ValueError: If a node with the given ID already exists.\n    \"\"\"\n    if node_id in self.nodes:\n        raise ValueError(f\"Node with ID {node_id} already exists\")\n\n    node = Node(node_id, attributes)\n    self.nodes[node_id] = node\n    return node\n</code></pre>"},{"location":"api/#sim_lab.core.NetworkSimulation.calculate_metrics","title":"<code>calculate_metrics()</code>","text":"<p>Calculate metrics for the current network state.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary of network metrics.</p> Source code in <code>src/sim_lab/core/network_simulation.py</code> <pre><code>def calculate_metrics(self) -&gt; Dict[str, Any]:\n    \"\"\"Calculate metrics for the current network state.\n\n    Returns:\n        A dictionary of network metrics.\n    \"\"\"\n    # Number of nodes and edges\n    num_nodes = len(self.nodes)\n    num_edges = len(self.edges)\n\n    # Average degree\n    total_degree = sum(len(node.neighbors) for node in self.nodes.values())\n    avg_degree = total_degree / num_nodes if num_nodes &gt; 0 else 0\n\n    # Density (ratio of actual to possible edges)\n    possible_edges = num_nodes * (num_nodes - 1)\n    if self.directed:\n        density = num_edges / possible_edges if possible_edges &gt; 0 else 0\n    else:\n        density = 2 * num_edges / possible_edges if possible_edges &gt; 0 else 0\n\n    # Result dictionary\n    metrics = {\n        'num_nodes': num_nodes,\n        'num_edges': num_edges,\n        'avg_degree': avg_degree,\n        'density': density\n    }\n\n    return metrics\n</code></pre>"},{"location":"api/#sim_lab.core.NetworkSimulation.get_adjacency_matrix","title":"<code>get_adjacency_matrix()</code>","text":"<p>Get the adjacency matrix of the network.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>A NumPy array representing the adjacency matrix, with weights if applicable.</p> Source code in <code>src/sim_lab/core/network_simulation.py</code> <pre><code>def get_adjacency_matrix(self) -&gt; np.ndarray:\n    \"\"\"Get the adjacency matrix of the network.\n\n    Returns:\n        A NumPy array representing the adjacency matrix, with weights if applicable.\n    \"\"\"\n    # Create a mapping from node IDs to indices\n    node_ids = list(self.nodes.keys())\n    node_to_index = {node_id: i for i, node_id in enumerate(node_ids)}\n\n    # Initialize the adjacency matrix\n    n = len(node_ids)\n    adj_matrix = np.zeros((n, n))\n\n    # Fill in the adjacency matrix\n    for edge in self.edges:\n        i = node_to_index[edge.source]\n        j = node_to_index[edge.target]\n        adj_matrix[i, j] = edge.weight\n        if not edge.directed:\n            adj_matrix[j, i] = edge.weight\n\n    return adj_matrix\n</code></pre>"},{"location":"api/#sim_lab.core.NetworkSimulation.get_degree_distribution","title":"<code>get_degree_distribution()</code>","text":"<p>Get the degree distribution of the network.</p> <p>Returns:</p> Type Description <code>Dict[int, int]</code> <p>A dictionary mapping degrees to the number of nodes with that degree.</p> Source code in <code>src/sim_lab/core/network_simulation.py</code> <pre><code>def get_degree_distribution(self) -&gt; Dict[int, int]:\n    \"\"\"Get the degree distribution of the network.\n\n    Returns:\n        A dictionary mapping degrees to the number of nodes with that degree.\n    \"\"\"\n    degrees = [len(node.neighbors) for node in self.nodes.values()]\n    degree_counts = {}\n    for degree in degrees:\n        degree_counts[degree] = degree_counts.get(degree, 0) + 1\n    return degree_counts\n</code></pre>"},{"location":"api/#sim_lab.core.NetworkSimulation.get_edge_attribute_history","title":"<code>get_edge_attribute_history(source, target, attribute)</code>","text":"<p>Get the history of a specific edge attribute.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Any</code> <p>Source node ID.</p> required <code>target</code> <code>Any</code> <p>Target node ID.</p> required <code>attribute</code> <code>str</code> <p>The name of the attribute.</p> required <p>Returns:</p> Type Description <code>List[Any]</code> <p>List of values for the attribute over time.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the edge doesn't exist or history wasn't saved.</p> Source code in <code>src/sim_lab/core/network_simulation.py</code> <pre><code>def get_edge_attribute_history(self, source: Any, target: Any, attribute: str) -&gt; List[Any]:\n    \"\"\"Get the history of a specific edge attribute.\n\n    Args:\n        source: Source node ID.\n        target: Target node ID.\n        attribute: The name of the attribute.\n\n    Returns:\n        List of values for the attribute over time.\n\n    Raises:\n        ValueError: If the edge doesn't exist or history wasn't saved.\n    \"\"\"\n    if not self.save_history:\n        raise ValueError(\"Edge history wasn't saved. Set save_history=True when creating the simulation.\")\n\n    # Find the edge\n    for edge in self.edges:\n        if edge.source == source and edge.target == target:\n            return edge.get_attribute_history(attribute)\n\n    # Check for undirected edge in reverse direction\n    if not self.directed:\n        for edge in self.edges:\n            if edge.source == target and edge.target == source:\n                return edge.get_attribute_history(attribute)\n\n    raise ValueError(f\"Edge from {source} to {target} doesn't exist\")\n</code></pre>"},{"location":"api/#sim_lab.core.NetworkSimulation.get_node_attribute_history","title":"<code>get_node_attribute_history(node_id, attribute)</code>","text":"<p>Get the history of a specific node attribute.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>Any</code> <p>The ID of the node.</p> required <code>attribute</code> <code>str</code> <p>The name of the attribute.</p> required <p>Returns:</p> Type Description <code>List[Any]</code> <p>List of values for the attribute over time.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the node doesn't exist or history wasn't saved.</p> Source code in <code>src/sim_lab/core/network_simulation.py</code> <pre><code>def get_node_attribute_history(self, node_id: Any, attribute: str) -&gt; List[Any]:\n    \"\"\"Get the history of a specific node attribute.\n\n    Args:\n        node_id: The ID of the node.\n        attribute: The name of the attribute.\n\n    Returns:\n        List of values for the attribute over time.\n\n    Raises:\n        ValueError: If the node doesn't exist or history wasn't saved.\n    \"\"\"\n    if not self.save_history:\n        raise ValueError(\"Node history wasn't saved. Set save_history=True when creating the simulation.\")\n\n    if node_id not in self.nodes:\n        raise ValueError(f\"Node with ID {node_id} doesn't exist\")\n\n    return self.nodes[node_id].get_attribute_history(attribute)\n</code></pre>"},{"location":"api/#sim_lab.core.NetworkSimulation.get_parameters_info","title":"<code>get_parameters_info()</code>  <code>classmethod</code>","text":"<p>Get information about the parameters required by this simulation.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, Any]]</code> <p>A dictionary mapping parameter names to their metadata.</p> Source code in <code>src/sim_lab/core/network_simulation.py</code> <pre><code>@classmethod\ndef get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n    \"\"\"Get information about the parameters required by this simulation.\n\n    Returns:\n        A dictionary mapping parameter names to their metadata.\n    \"\"\"\n    # Get base parameters from parent class\n    params = super().get_parameters_info()\n\n    # Add class-specific parameters\n    params.update({\n        'initial_nodes': {\n            'type': 'Dict[Any, Dict[str, Any]]',\n            'description': 'Dictionary mapping node IDs to attribute dictionaries',\n            'required': False,\n            'default': '{}'\n        },\n        'initial_edges': {\n            'type': 'List[Tuple[Any, Any, Dict[str, Any]]]',\n            'description': 'List of (source, target, attributes) tuples',\n            'required': False,\n            'default': '[]'\n        },\n        'update_function': {\n            'type': 'Callable',\n            'description': 'Function that updates the network at each time step',\n            'required': False,\n            'default': 'None'\n        },\n        'directed': {\n            'type': 'bool',\n            'description': 'Whether the network is directed',\n            'required': False,\n            'default': 'False'\n        },\n        'save_history': {\n            'type': 'bool',\n            'description': 'Whether to save node and edge history',\n            'required': False,\n            'default': 'False'\n        }\n    })\n\n    return params\n</code></pre>"},{"location":"api/#sim_lab.core.NetworkSimulation.remove_edge","title":"<code>remove_edge(source, target)</code>","text":"<p>Remove an edge from the network.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Any</code> <p>Source node ID.</p> required <code>target</code> <code>Any</code> <p>Target node ID.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the edge doesn't exist.</p> Source code in <code>src/sim_lab/core/network_simulation.py</code> <pre><code>def remove_edge(self, source: Any, target: Any) -&gt; None:\n    \"\"\"Remove an edge from the network.\n\n    Args:\n        source: Source node ID.\n        target: Target node ID.\n\n    Raises:\n        ValueError: If the edge doesn't exist.\n    \"\"\"\n    # Find the edge\n    for i, edge in enumerate(self.edges):\n        if edge.source == source and edge.target == target:\n            # Remove from neighbor lists\n            self.nodes[source].remove_neighbor(target)\n            if not edge.directed:\n                self.nodes[target].remove_neighbor(source)\n\n            # Remove the edge\n            self.edges.pop(i)\n            return\n\n    # Check for undirected edge in reverse direction\n    if not self.directed:\n        for i, edge in enumerate(self.edges):\n            if edge.source == target and edge.target == source:\n                # Remove from neighbor lists\n                self.nodes[target].remove_neighbor(source)\n                self.nodes[source].remove_neighbor(target)\n\n                # Remove the edge\n                self.edges.pop(i)\n                return\n\n    raise ValueError(f\"Edge from {source} to {target} doesn't exist\")\n</code></pre>"},{"location":"api/#sim_lab.core.NetworkSimulation.remove_node","title":"<code>remove_node(node_id)</code>","text":"<p>Remove a node from the network.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>Any</code> <p>The ID of the node to remove.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the node doesn't exist.</p> Source code in <code>src/sim_lab/core/network_simulation.py</code> <pre><code>def remove_node(self, node_id: Any) -&gt; None:\n    \"\"\"Remove a node from the network.\n\n    Args:\n        node_id: The ID of the node to remove.\n\n    Raises:\n        ValueError: If the node doesn't exist.\n    \"\"\"\n    if node_id not in self.nodes:\n        raise ValueError(f\"Node with ID {node_id} doesn't exist\")\n\n    # Remove edges connected to this node\n    self.edges = [edge for edge in self.edges if edge.source != node_id and edge.target != node_id]\n\n    # Remove node from neighbor lists\n    for node in self.nodes.values():\n        if node_id in node.neighbors:\n            node.neighbors.remove(node_id)\n\n    # Remove the node\n    del self.nodes[node_id]\n</code></pre>"},{"location":"api/#sim_lab.core.NetworkSimulation.reset","title":"<code>reset()</code>","text":"<p>Reset the simulation to its initial state.</p> Source code in <code>src/sim_lab/core/network_simulation.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the simulation to its initial state.\"\"\"\n    super().reset()\n\n    # Clear metrics\n    self.metrics = []\n\n    # Clear node and edge history\n    if self.save_history:\n        for node in self.nodes.values():\n            node.history = [node.attributes.copy()]\n\n        for edge in self.edges:\n            state = edge.attributes.copy()\n            state['weight'] = edge.weight\n            edge.history = [state]\n</code></pre>"},{"location":"api/#sim_lab.core.NetworkSimulation.run_simulation","title":"<code>run_simulation()</code>","text":"<p>Run the network simulation.</p> <p>In each step, the network is updated according to the update function.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>A list of dictionaries containing network metrics for each time step.</p> Source code in <code>src/sim_lab/core/network_simulation.py</code> <pre><code>def run_simulation(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"Run the network simulation.\n\n    In each step, the network is updated according to the update function.\n\n    Returns:\n        A list of dictionaries containing network metrics for each time step.\n    \"\"\"\n    self.reset()\n\n    # Initialize history if tracking\n    if self.save_history:\n        for node in self.nodes.values():\n            node.history = [node.attributes.copy()]\n\n        for edge in self.edges:\n            state = edge.attributes.copy()\n            state['weight'] = edge.weight\n            edge.history = [state]\n\n    # Calculate initial metrics\n    self.metrics = [self.calculate_metrics()]\n\n    # Run for specified number of days\n    for day in range(1, self.days):\n        # Update the network\n        self.update_function(self, day)\n\n        # Save history if tracking\n        if self.save_history:\n            for node in self.nodes.values():\n                node.save_history()\n\n            for edge in self.edges:\n                edge.save_history()\n\n        # Calculate metrics\n        self.metrics.append(self.calculate_metrics())\n\n    return self.metrics\n</code></pre>"},{"location":"cli/","title":"Command Line Interface","text":"<p>SimLab provides a command-line interface (CLI) for running simulations, launching interfaces, and managing the application.</p>"},{"location":"cli/#installation","title":"Installation","text":"<p>Make sure you have installed SimLab with the CLI dependencies:</p> <pre><code>pip install simnexus[cli]\n</code></pre>"},{"location":"cli/#command-structure","title":"Command Structure","text":"<p>The CLI is structured with a hierarchical command system:</p> <pre><code>simnexus\n\u251c\u2500\u2500 sim              Commands for running simulations\n\u2502   \u251c\u2500\u2500 stock        Stock market simulation commands\n\u2502   \u2502   \u2514\u2500\u2500 run      Run a stock market simulation\n\u2502   \u251c\u2500\u2500 resource     Resource fluctuations simulation commands\n\u2502   \u2502   \u2514\u2500\u2500 run      Run a resource fluctuations simulation\n\u2502   \u2514\u2500\u2500 product      Product popularity simulation commands\n\u2502       \u2514\u2500\u2500 run      Run a product popularity simulation\n\u251c\u2500\u2500 ui               Launch user interfaces\n\u2502   \u251c\u2500\u2500 web          Launch the web interface\n\u2502   \u2514\u2500\u2500 tui          Launch the terminal user interface\n\u2514\u2500\u2500 util             Utility commands\n    \u2514\u2500\u2500 info         Show information about SimLab\n</code></pre>"},{"location":"cli/#running-simulations","title":"Running Simulations","text":""},{"location":"cli/#stock-market-simulation","title":"Stock Market Simulation","text":"<pre><code># Run a basic stock market simulation\nsimnexus sim stock run --start-price 100 --days 365 --volatility 0.02 --drift 0.001\n\n# Include a market event\nsimnexus sim stock run --start-price 150 --days 500 --volatility 0.03 --drift 0.002 --event-day 250 --event-impact -0.15\n\n# Save the results to a specific file\nsimnexus sim stock run --start-price 100 --days 365 --volatility 0.02 --drift 0.001 --output my_simulation.csv\n\n# Visualize the results (requires matplotlib)\nsimnexus sim stock run --days 365 --event-day 180 --event-impact -0.2 --viz\n</code></pre>"},{"location":"cli/#resource-fluctuations-simulation","title":"Resource Fluctuations Simulation","text":"<pre><code># Run a basic resource simulation\nsimnexus sim resource run --start-price 50 --days 365 --volatility 0.05 --drift 0.001\n\n# Include a supply disruption\nsimnexus sim resource run --start-price 75 --days 500 --volatility 0.04 --drift 0.002 --disruption-day 200 --disruption-severity 0.3\n\n# Save the results to a specific file\nsimnexus sim resource run --start-price 50 --days 365 --volatility 0.05 --drift 0.001 --output resource_prices.csv\n\n# Visualize the results (requires matplotlib)\nsimnexus sim resource run --disruption-day 180 --disruption-severity 0.3 --viz\n</code></pre>"},{"location":"cli/#running-user-interfaces","title":"Running User Interfaces","text":""},{"location":"cli/#web-interface","title":"Web Interface","text":"<pre><code># Start the web interface with default settings\nsimnexus ui web\n\n# Specify host and port\nsimnexus ui web --host 0.0.0.0 --port 5000\n\n# Enable auto-reload for development\nsimnexus ui web --reload\n</code></pre>"},{"location":"cli/#terminal-user-interface","title":"Terminal User Interface","text":"<pre><code># Start the terminal user interface\nsimnexus ui tui\n</code></pre>"},{"location":"cli/#utility-commands","title":"Utility Commands","text":"<pre><code># Show information about SimLab\nsimnexus util info\n\n# Show version\nsimnexus --version\n</code></pre>"},{"location":"cli/#getting-help","title":"Getting Help","text":"<p>You can get help for any command by using the <code>--help</code> flag:</p> <pre><code># Get general help\nsimnexus --help\n\n# Get help for a command group\nsimnexus sim --help\n\n# Get help for a specific simulation type\nsimnexus sim stock --help\n\n# Get help for a specific command\nsimnexus sim stock run --help\n</code></pre>"},{"location":"contact/","title":"Contact Us","text":"<p>If you have any questions, need support, or wish to provide feedback about SimLab, please feel free to reach out. We value your input and are here to help.</p>"},{"location":"contact/#general-inquiries","title":"General Inquiries","text":"<p>For general questions about SimLab or how to use it, please email us at:</p> <ul> <li>Email: support@simnexus.com</li> </ul> <p>Please allow 24-48 hours for a response, as we strive to provide detailed and helpful answers to all inquiries.</p>"},{"location":"contact/#technical-support","title":"Technical Support","text":"<p>If you're experiencing technical issues or need help troubleshooting, you can:</p> <ul> <li>Submit an Issue: Visit our GitHub Issues Page to report a bug or a problem. Please check to see if your issue has already been reported or addressed before opening a new issue.</li> </ul>"},{"location":"contact/#feature-requests","title":"Feature Requests","text":"<p>We are always looking to improve SimLab and welcome your ideas and proposals for new features:</p> <ul> <li>Feature Suggestions: Please submit your feature requests through our GitHub Issues Page. Tag your post with the 'feature request' label so we can easily identify it.</li> </ul>"},{"location":"contact/#follow-us","title":"Follow Us","text":"<p>Stay updated on the latest developments and updates of SimLab by following us on social media:</p> <ul> <li>Twitter: @SimLabTech</li> <li>LinkedIn: SimLab Technologies</li> </ul>"},{"location":"contact/#mailing-list","title":"Mailing List","text":"<p>Join our mailing list to receive updates, news, and special offers related to SimLab:</p> <ul> <li>Sign Up: Join Mailing List [Link to mailing list subscription form]</li> </ul> <p>Thank you for your interest in SimLab. We look forward to hearing from you and assisting you with your simulation needs!</p>"},{"location":"contribute/","title":"Contribute to Our Project","text":"<p>We welcome contributions from the community. Before contributing, please read our contribution guidelines to understand how you can help improve this project.</p> <p>Read the Contribution Guidelines</p>"},{"location":"getting_started/","title":"Getting Started with SimLab","text":"<p>Welcome to the getting started guide for SimLab, a toolkit for simulating various business scenarios including stock market fluctuations, resource price dynamics, and product popularity. This guide will walk you through the installation options and different ways to use SimLab.</p>"},{"location":"getting_started/#installation-options","title":"Installation Options","text":"<p>SimLab offers flexible installation options depending on your needs:</p>"},{"location":"getting_started/#basic-installation","title":"Basic Installation","text":"<p>For core simulation functionality only:</p> <pre><code>pip install simnexus\n</code></pre>"},{"location":"getting_started/#full-installation","title":"Full Installation","text":"<p>For all features including CLI, web interface, and development tools:</p> <pre><code>pip install simnexus[dev]\n</code></pre>"},{"location":"getting_started/#component-specific-installation","title":"Component-Specific Installation","text":"<p>For specific interfaces:</p> <pre><code># Command-line interface\npip install simnexus[cli]\n\n# Web interface\npip install simnexus[web]\n</code></pre>"},{"location":"getting_started/#install-from-github","title":"Install from GitHub","text":"<p>For the latest development version:</p> <pre><code>pip install git+https://github.com/michael-borck/simnexus.git\n</code></pre>"},{"location":"getting_started/#verify-installation","title":"Verify Installation","text":"<p>To ensure that SimLab was installed correctly:</p> <pre><code>python -c \"import simnexus; print(simnexus.__version__)\"\n</code></pre> <p>Or using the CLI:</p> <pre><code>simnexus --version\n</code></pre>"},{"location":"getting_started/#usage-methods","title":"Usage Methods","text":"<p>SimLab offers multiple ways to run simulations:</p>"},{"location":"getting_started/#1-python-library","title":"1. Python Library","text":"<p>Import SimLab in your Python code:</p> <pre><code>from simnexus import StockMarketSimulation\n\n# Create a simulation instance\nsim = StockMarketSimulation(\n    start_price=100,\n    days=365,\n    volatility=0.03,\n    drift=0.001,\n    event_day=180,\n    event_impact=-0.2,\n    random_seed=42\n)\n\n# Run the simulation\nprices = sim.run_simulation()\n\n# Use the results\nprint(f\"Final price: ${prices[-1]:.2f}\")\n</code></pre>"},{"location":"getting_started/#2-command-line-interface","title":"2. Command Line Interface","text":"<p>Run simulations directly from the command line:</p> <pre><code># Stock market simulation\nsimnexus sim stock run --days 365 --event-day 180 --event-impact -0.2 --output results.csv\n\n# Resource fluctuations simulation\nsimnexus sim resource run --volatility 0.05 --disruption-day 100 --disruption-severity 0.3\n</code></pre>"},{"location":"getting_started/#3-web-interface","title":"3. Web Interface","text":"<p>Launch the web interface for interactive simulation:</p> <pre><code>simnexus ui web\n</code></pre> <p>Then open your browser at http://localhost:8000.</p>"},{"location":"getting_started/#4-terminal-ui","title":"4. Terminal UI","text":"<p>Launch the terminal user interface (TUI):</p> <pre><code>simnexus ui tui\n</code></pre>"},{"location":"getting_started/#example-resources","title":"Example Resources","text":"<p>SimLab includes comprehensive examples to help you get started:</p> <ul> <li>Python Examples: Basic scripts showing simulation usage</li> <li>CLI Examples: Shell scripts demonstrating command-line capabilities  </li> <li>Jupyter Notebooks: Interactive examples for data analysis</li> </ul> <p>See the examples directory in the repository.</p>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the API documentation for detailed information on simulation classes</li> <li>Try different interfaces: CLI, TUI, or Web</li> <li>Check out the example code for practical applications</li> </ul>"},{"location":"getting_started/#getting-help","title":"Getting Help","text":"<p>If you encounter any issues or have questions:</p> <ul> <li>Check the documentation</li> <li>Run <code>simnexus --help</code> for CLI assistance</li> <li>Contact information is available on the Contact page</li> </ul> <p>Happy simulating with SimLab!</p>"},{"location":"teaching_guide/","title":"Teaching Guide for SimLab Simulation Framework","text":""},{"location":"teaching_guide/#overview","title":"Overview","text":"<p>This teaching guide is designed to help educators integrate the SimLab Simulation Framework into their coursework. The SimLab project provides a set of tools for simulating various scenarios, including continuous and discrete systems. It is an ideal resource for introducing students to complex concepts in a controlled and interactive environment.</p>"},{"location":"teaching_guide/#educational-objectives","title":"Educational Objectives","text":"<p>The primary educational objectives of using the SimLab Simulation Framework in an academic setting include:</p> <ul> <li>Understanding Core Principles: Students will learn the fundamental principles of simulation, including the differences and applications of continuous and discrete event simulations.</li> <li>Developing Practical Skills: Through hands-on exercises, students will develop skills in coding, problem-solving, and critical thinking.</li> <li>Applying Theoretical Knowledge: The framework allows students to apply theoretical knowledge to real-world-like scenarios, bridging the gap between theory and practice.</li> </ul>"},{"location":"teaching_guide/#course-integration","title":"Course Integration","text":""},{"location":"teaching_guide/#suggested-courses","title":"Suggested Courses","text":"<ul> <li>Introduction to Computational Modeling</li> <li>Systems Science and Engineering</li> <li>Computer Science Applications</li> <li>Data Science and Analytics</li> </ul>"},{"location":"teaching_guide/#module-breakdown","title":"Module Breakdown","text":"<ol> <li>Module 1: Introduction to Simulations</li> <li>Focus: Understanding the types of simulations.</li> <li> <p>Activities: Run pre-built simulations from the framework.</p> </li> <li> <p>Module 2: Working with Continuous Simulations</p> </li> <li>Focus: Explore continuous dynamics.</li> <li> <p>Activities: Modify parameters in <code>ContinuousSimulation</code> classes and observe outcomes.</p> </li> <li> <p>Module 3: Exploring Discrete Event Simulations</p> </li> <li>Focus: Dive into event-driven simulation mechanics.</li> <li> <p>Activities: Implement a simple queuing system using <code>DiscreteEventSimulation</code>.</p> </li> <li> <p>Module 4: Advanced Applications</p> </li> <li>Focus: Combine both types of simulations for complex scenarios.</li> <li>Activities: Students design a hybrid simulation applying learned concepts.</li> </ol>"},{"location":"teaching_guide/#assignments-and-projects","title":"Assignments and Projects","text":"<ul> <li>Assignment 1: Simulation Analysis Report</li> <li> <p>Task: Students run specific simulations and report on the dynamics and results.</p> </li> <li> <p>Project 1: Custom Simulation Development</p> </li> <li>Task: Students develop their own simulation based on a real-world scenario.</li> </ul>"},{"location":"teaching_guide/#assessment-criteria","title":"Assessment Criteria","text":"<ul> <li>Understanding and Application: Ability to explain and apply simulation concepts correctly.</li> <li>Technical Implementation: Accuracy and efficiency of the simulation code.</li> <li>Creativity and Insight: Originality in the application of simulations to novel scenarios.</li> <li>Presentation and Documentation: Clarity and thoroughness in documentation and presentation of the work.</li> </ul>"},{"location":"teaching_guide/#resources","title":"Resources","text":"<ul> <li>Documentation: Refer to the main README.md for technical details and setup instructions.</li> <li>Sample Notebooks: Access provided Jupyter notebooks for examples and templates.</li> </ul> <p>Absolutely, it is definitely worthwhile to demonstrate how the same repository can be adapted to different educational focuses, such as simulation principles and object-oriented programming (OOP). Highlighting this versatility in your <code>TEACHING_GUIDE.md</code> can inspire educators to tailor the content to various courses and learning outcomes. Here\u2019s how you can structure this section to illustrate different potential course focuses using the SimLab framework.</p>"},{"location":"teaching_guide/#adapting-simlab-to-various-course-focuses","title":"Adapting SimLab to Various Course Focuses","text":"<p>SimLab\u2019s flexible design makes it an excellent resource for courses with varying educational objectives. Below are examples of how the repository can be tailored to focus on different aspects of computer science and engineering education.</p>"},{"location":"teaching_guide/#1-simulation-principles-focus","title":"1. Simulation Principles Focus","text":"<p>Objective: To deepen understanding of simulation techniques and their applications in real-world scenarios.</p> <p>Course Examples: - Systems Modeling and Simulation: Focus on using SimLab for modeling complex systems and processes. - Computational Physics or Biology: Use simulations to explore physical or biological phenomena.</p> <p>Module Structure: - Introduction to Different Types of Simulations (Continuous vs. Discrete) - Applying Statistical Methods to Analyze Simulation Data - Case Studies: Using Simulations in Industry-specific Applications</p>"},{"location":"teaching_guide/#2-object-oriented-programming-oop-focus","title":"2. Object-Oriented Programming (OOP) Focus","text":"<p>Objective: To enhance proficiency in OOP principles and their practical application in software development.</p> <p>Course Examples: - Advanced Programming Techniques: Emphasize OOP principles, design patterns, and refactoring using SimLab. - Software Engineering: Focus on software design and architecture using OOP methodologies exemplified through SimLab.</p> <p>Module Structure: - Basics of OOP: Classes, Objects, and Encapsulation - Advanced OOP: Inheritance, Polymorphism, and Abstract Classes - Design Patterns and Best Practices in OOP</p>"},{"location":"teaching_guide/#3-software-development-practices-focus","title":"3. Software Development Practices Focus","text":"<p>Objective: To foster skills in software development lifecycle and collaborative coding practices.</p> <p>Course Examples: - Software Development Process: Introduce students to version control, code reviews, and CI/CD processes. - Collaborative Software Projects: Use SimLab as the base for team projects focusing on collaborative development and maintenance.</p> <p>Module Structure: - Version Control and GitHub Workflow - Continuous Integration and Testing with GitHub Actions - Code Review and Documentation Standards</p>"},{"location":"teaching_guide/#customizing-modules","title":"Customizing Modules","text":"<p>Educators are encouraged to mix and match elements from these suggested structures or add new modules based on the specific needs and goals of their courses. SimLab\u2019s architecture is designed to be robust yet flexible enough to support diverse teaching strategies and learning objectives.</p>"},{"location":"teaching_guide/#support-for-educators","title":"Support for Educators","text":"<p>For additional support or to share feedback about this teaching guide, please contact the project maintainers at [your.email@example.com].</p>"},{"location":"tui/","title":"Terminal User Interface (TUI)","text":"<p>SimLab provides a Terminal User Interface (TUI) for running simulations interactively within your terminal.</p>"},{"location":"tui/#installation","title":"Installation","text":"<p>Make sure you have installed SimLab with the TUI dependencies:</p> <pre><code>pip install simnexus[dev]\n</code></pre>"},{"location":"tui/#running-the-tui","title":"Running the TUI","text":"<p>Launch the TUI with:</p> <pre><code>simnexus ui tui\n</code></pre>"},{"location":"tui/#interface-overview","title":"Interface Overview","text":"<p>The TUI is organized into several screens:</p> <ol> <li>Welcome Screen: Choose a simulation type</li> <li>Parameter Forms: Configure simulation parameters</li> <li>Results Screen: View simulation results and save data</li> </ol>"},{"location":"tui/#navigation","title":"Navigation","text":"<ul> <li>Use Tab to navigate between fields</li> <li>Use Enter to activate buttons</li> <li>Use Arrow Keys to move between options and navigate widgets</li> </ul>"},{"location":"tui/#features","title":"Features","text":""},{"location":"tui/#simulation-selection","title":"Simulation Selection","text":"<p>The welcome screen allows you to select from the available simulation types:</p> <ul> <li>Stock Market Simulation</li> <li>Resource Fluctuations Simulation</li> <li>Product Popularity Simulation</li> </ul>"},{"location":"tui/#parameter-configuration","title":"Parameter Configuration","text":"<p>Each simulation type has its own form for setting parameters:</p> <ul> <li>Stock Market Simulation:</li> <li>Starting Price</li> <li>Days</li> <li>Volatility</li> <li>Drift</li> <li>Event Day (optional)</li> <li> <p>Event Impact</p> </li> <li> <p>Resource Fluctuations Simulation:</p> </li> <li>Starting Price</li> <li>Days</li> <li>Volatility</li> <li>Drift</li> <li>Supply Disruption Day (optional)</li> <li> <p>Disruption Severity</p> </li> <li> <p>Product Popularity Simulation:</p> </li> <li>Days</li> <li>Initial Popularity</li> <li>Virality Factor</li> <li>Marketing Effectiveness</li> </ul>"},{"location":"tui/#results-visualization","title":"Results Visualization","text":"<p>The results screen displays:</p> <ul> <li>Simulation parameters used</li> <li>A textual chart of the results</li> <li>Options to save the results or start a new simulation</li> </ul>"},{"location":"tui/#saving-results","title":"Saving Results","text":"<p>Results can be saved to CSV files for further analysis. The files are saved to your home directory in a <code>simnexus_results</code> folder.</p>"},{"location":"web/","title":"Web Interface","text":"<p>SimLab provides a web interface built with FastHTML for running simulations through a browser.</p>"},{"location":"web/#installation","title":"Installation","text":"<p>Make sure you have installed SimLab with the web dependencies:</p> <pre><code>pip install simnexus[web]\n</code></pre>"},{"location":"web/#running-the-web-server","title":"Running the Web Server","text":"<p>Start the web server with:</p> <pre><code>simnexus ui web\n</code></pre> <p>By default, the server runs on http://localhost:8000.</p> <p>For custom host and port:</p> <pre><code>simnexus ui web --host 0.0.0.0 --port 5000\n</code></pre>"},{"location":"web/#web-interface-features","title":"Web Interface Features","text":"<p>Navigate to http://localhost:8000 in your browser to access the web interface, which provides:</p> <ul> <li>Interactive forms for configuring simulations</li> <li>Visual charts of simulation results (powered by Chart.js)</li> <li>Statistical analysis of simulation results</li> <li>Options to download simulation data as CSV</li> </ul>"},{"location":"web/#simulation-types","title":"Simulation Types","text":""},{"location":"web/#stock-market-simulation","title":"Stock Market Simulation","text":"<p>Configure and run stock price simulations with parameters:</p> <ul> <li>Starting Price</li> <li>Days to simulate</li> <li>Volatility</li> <li>Drift (daily price trend)</li> <li>Event Day (optional)</li> <li>Event Impact</li> </ul> <p>The simulation visualizes market events as markers on the chart, making it easy to see the impact of major events.</p>"},{"location":"web/#resource-fluctuations-simulation","title":"Resource Fluctuations Simulation","text":"<p>Model resource price changes with parameters:</p> <ul> <li>Starting Price</li> <li>Days to simulate</li> <li>Volatility</li> <li>Drift</li> <li>Supply Disruption Day (optional)</li> <li>Disruption Severity</li> </ul>"},{"location":"web/#product-popularity-simulation","title":"Product Popularity Simulation","text":"<p>Coming soon!</p>"},{"location":"web/#behind-the-scenes-fasthtml","title":"Behind the Scenes - FastHTML","text":"<p>The SimLab web interface is built using FastHTML, which combines:</p> <ul> <li>Starlette for ASGI web server</li> <li>HTMX for interactive browser experiences</li> <li>FastTags (FT) for dynamic HTML generation</li> </ul> <p>FastHTML allows SimLab to create a modern, interactive web interface without the complexity of a full JavaScript framework.</p>"},{"location":"web/#deployment","title":"Deployment","text":"<p>For production deployment, we recommend using Uvicorn behind a reverse proxy like Nginx:</p> <pre><code>uvicorn simnexus.web.app:create_app --host 0.0.0.0 --port 8000\n</code></pre> <p>Or with Docker (see the project repository for the Dockerfile).</p>"},{"location":"developers/architecture/","title":"SimLab Architecture","text":"<p>This document outlines the high-level architecture of the SimLab framework, explaining its components, design principles, and how they interact.</p>"},{"location":"developers/architecture/#overview","title":"Overview","text":"<p>SimLab is designed around a modular, extensible architecture that allows for:</p> <ol> <li>Consistent interface across different simulation types</li> <li>Dynamic discovery and instantiation of simulation models</li> <li>Easy extension with new simulation types</li> <li>Clear separation of concerns between components</li> </ol> <p>The architecture follows object-oriented principles, with a focus on:</p> <ul> <li>Inheritance: All simulators inherit from a common base class</li> <li>Abstraction: Complex simulation logic is encapsulated in specific classes</li> <li>Polymorphism: Common interface across different simulator types</li> <li>Encapsulation: Internal simulation state is managed by each simulator</li> </ul>"},{"location":"developers/architecture/#core-components","title":"Core Components","text":""},{"location":"developers/architecture/#base-simulation","title":"Base Simulation","text":"<p>At the heart of SimLab is the <code>BaseSimulation</code> abstract class, which defines the common interface for all simulations:</p> <pre><code>BaseSimulation\n\u251c\u2500\u2500 run_simulation()\n\u251c\u2500\u2500 reset()\n\u251c\u2500\u2500 get_parameters_info()\n\u2514\u2500\u2500 _initialize_random_generators()\n</code></pre> <p>This class ensures all simulators provide a consistent interface and handles common functionality like random number generation.</p>"},{"location":"developers/architecture/#registry-system","title":"Registry System","text":"<p>The <code>SimulatorRegistry</code> provides dynamic discovery and instantiation of simulation models:</p> <pre><code>SimulatorRegistry\n\u251c\u2500\u2500 register()\n\u251c\u2500\u2500 unregister()\n\u251c\u2500\u2500 get()\n\u251c\u2500\u2500 list_simulators()\n\u251c\u2500\u2500 create()\n\u2514\u2500\u2500 load_simulator_from_path()\n</code></pre> <p>The registry allows simulations to be referenced by name, decoupling the code that uses simulations from the specific simulation implementations.</p>"},{"location":"developers/architecture/#simulation-categories","title":"Simulation Categories","text":"<p>SimLab organizes simulations into several categories, each with its own specialized base class:</p> <pre><code>BaseSimulation\n\u251c\u2500\u2500 BasicSimulation\n\u2502   \u251c\u2500\u2500 StockMarketSimulation\n\u2502   \u251c\u2500\u2500 ResourceFluctuationsSimulation\n\u2502   \u2514\u2500\u2500 ProductPopularitySimulation\n\u251c\u2500\u2500 DiscreteEventSimulation\n\u2502   \u2514\u2500\u2500 QueueingSimulation\n\u251c\u2500\u2500 StatisticalSimulation\n\u2502   \u251c\u2500\u2500 MonteCarloSimulation\n\u2502   \u2514\u2500\u2500 MarkovChainSimulation\n\u251c\u2500\u2500 AgentBasedSimulation\n\u251c\u2500\u2500 SystemDynamicsSimulation\n\u251c\u2500\u2500 NetworkSimulation\n\u251c\u2500\u2500 EcologicalSimulation\n\u2502   \u2514\u2500\u2500 PredatorPreySimulation\n\u2514\u2500\u2500 DomainSpecificSimulation\n    \u251c\u2500\u2500 EpidemiologicalSimulation\n    \u251c\u2500\u2500 CellularAutomatonSimulation\n    \u2514\u2500\u2500 SupplyChainSimulation\n</code></pre>"},{"location":"developers/architecture/#directory-structure","title":"Directory Structure","text":"<p>The project follows a clear directory structure:</p> <pre><code>sim_lab/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 cli/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 main.py\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 settings.py\n\u251c\u2500\u2500 core/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 base_simulation.py\n\u2502   \u251c\u2500\u2500 registry.py\n\u2502   \u2514\u2500\u2500 [specific simulation files]\n\u251c\u2500\u2500 tui/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 app.py\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 io.py\n\u2502   \u2514\u2500\u2500 validation.py\n\u251c\u2500\u2500 viz/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 plots.py\n\u2514\u2500\u2500 web/\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 app.py\n</code></pre> <ul> <li>core/: Contains the simulation models and core functionality</li> <li>cli/: Command-line interface</li> <li>tui/: Text-based user interface</li> <li>web/: Web-based interface</li> <li>config/: Configuration settings</li> <li>utils/: Utility functions</li> <li>viz/: Visualization components</li> </ul>"},{"location":"developers/architecture/#interfaces","title":"Interfaces","text":"<p>SimLab provides multiple interfaces for interacting with simulations:</p> <ol> <li>Python API: Direct use in Python code</li> <li>CLI: Command-line interface</li> <li>TUI: Text-based user interface</li> <li>Web: Web-based interface</li> </ol> <p>Each interface uses the same underlying simulation models, providing different ways to access the functionality.</p>"},{"location":"developers/architecture/#design-patterns","title":"Design Patterns","text":"<p>SimLab uses several design patterns:</p> <ol> <li>Factory Pattern: The registry acts as a factory for creating simulations</li> <li>Singleton Pattern: The registry is a singleton</li> <li>Decorator Pattern: Registration is done through decorators</li> <li>Strategy Pattern: Different simulation algorithms implement the same interface</li> <li>Observer Pattern: Some simulations use observers to track state changes</li> </ol>"},{"location":"developers/architecture/#extension-points","title":"Extension Points","text":"<p>SimLab can be extended in several ways:</p> <ol> <li>New Simulation Types: Create a new class inheriting from <code>BaseSimulation</code></li> <li>Custom Visualizations: Add new visualization methods</li> <li>Additional Interfaces: Create new interfaces to the simulation models</li> <li>Plugins: Develop plugins that can be loaded at runtime</li> </ol>"},{"location":"developers/architecture/#data-flow","title":"Data Flow","text":"<p>A typical data flow through the system:</p> <ol> <li>User selects a simulation type and parameters</li> <li>Interface code creates a simulation instance through the registry</li> <li>Simulation runs and generates results</li> <li>Results are processed, visualized, or exported</li> </ol>"},{"location":"developers/architecture/#dependencies","title":"Dependencies","text":"<p>SimLab has minimal external dependencies:</p> <ul> <li>NumPy: For numerical operations</li> <li>Matplotlib (optional): For visualization</li> <li>Rich (optional): For TUI</li> <li>Flask (optional): For web interface</li> </ul>"},{"location":"developers/architecture/#future-architecture-directions","title":"Future Architecture Directions","text":"<p>Planned architectural improvements:</p> <ol> <li>Plugin System: More formal plugin architecture</li> <li>Distributed Simulations: Support for distributed computing</li> <li>Cloud Integration: Deployment to cloud environments</li> <li>Real-time Visualization: Live updating visualizations</li> <li>Interoperability: Better integration with other tools</li> </ol>"},{"location":"developers/creating_simulators/","title":"Creating New Simulators","text":"<p>This guide explains how to create new simulation types for SimLab, ensuring they integrate properly with the framework.</p>"},{"location":"developers/creating_simulators/#overview","title":"Overview","text":"<p>Creating a new simulator in SimLab involves:</p> <ol> <li>Creating a new class that inherits from <code>BaseSimulation</code></li> <li>Implementing the required methods</li> <li>Registering the simulator with the registry</li> <li>Adding appropriate documentation</li> </ol>"},{"location":"developers/creating_simulators/#basic-simulator-structure","title":"Basic Simulator Structure","text":"<p>Here's the basic structure of a simulator:</p> <pre><code>from sim_lab.core import BaseSimulation, SimulatorRegistry\nfrom typing import List, Union, Optional, Dict, Any\n\n@SimulatorRegistry.register(\"MySimulator\")\nclass MyCustomSimulation(BaseSimulation):\n    \"\"\"My custom simulation implementation.\n\n    This simulation models [describe what it models].\n\n    Attributes:\n        param1: Description of param1\n        param2: Description of param2\n    \"\"\"\n\n    def __init__(\n        self,\n        days: int,\n        param1: float,\n        param2: str,\n        random_seed: Optional[int] = None\n    ):\n        \"\"\"Initialize the simulation.\n\n        Args:\n            days: Duration of the simulation in days/steps\n            param1: Description of param1\n            param2: Description of param2\n            random_seed: Seed for random number generation\n        \"\"\"\n        super().__init__(days=days, random_seed=random_seed)\n\n        # Store parameters\n        self.param1 = param1\n        self.param2 = param2\n\n        # Initialize simulation state\n        self.results = []\n\n    def run_simulation(self) -&gt; List[Union[float, int]]:\n        \"\"\"Run the simulation and return results.\n\n        Returns:\n            A list of simulation results over time\n        \"\"\"\n        # Reset results\n        self.results = []\n\n        # Run simulation for the specified number of days\n        for day in range(self.days):\n            # Calculate result for this day\n            result = self._calculate_day_result(day)\n\n            # Store result\n            self.results.append(result)\n\n        return self.results\n\n    def _calculate_day_result(self, day: int) -&gt; float:\n        \"\"\"Calculate the result for a specific day.\n\n        Args:\n            day: The current day\n\n        Returns:\n            The result for this day\n        \"\"\"\n        # Implement your simulation logic here\n        return 0.0\n\n    @classmethod\n    def get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n        \"\"\"Get information about the parameters required by this simulation.\n\n        Returns:\n            A dictionary mapping parameter names to their metadata\n        \"\"\"\n        params = super().get_parameters_info()\n        params.update({\n            'param1': {\n                'type': 'float',\n                'description': 'Description of param1',\n                'required': True\n            },\n            'param2': {\n                'type': 'str',\n                'description': 'Description of param2',\n                'required': True\n            }\n        })\n        return params\n</code></pre>"},{"location":"developers/creating_simulators/#key-components","title":"Key Components","text":""},{"location":"developers/creating_simulators/#class-declaration-and-registration","title":"Class Declaration and Registration","text":"<pre><code>@SimulatorRegistry.register(\"MySimulator\")\nclass MyCustomSimulation(BaseSimulation):\n</code></pre> <p>The <code>@SimulatorRegistry.register()</code> decorator registers your simulation with the registry. You can provide a name for the registry; if omitted, the class name will be used.</p>"},{"location":"developers/creating_simulators/#constructor","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    days: int,\n    param1: float,\n    param2: str,\n    random_seed: Optional[int] = None\n):\n    super().__init__(days=days, random_seed=random_seed)\n\n    # Store parameters\n    self.param1 = param1\n    self.param2 = param2\n\n    # Initialize simulation state\n    self.results = []\n</code></pre> <p>The constructor must: 1. Call <code>super().__init__()</code> with the <code>days</code> and <code>random_seed</code> parameters 2. Store simulation-specific parameters 3. Initialize the simulation state</p>"},{"location":"developers/creating_simulators/#run_simulation-method","title":"run_simulation Method","text":"<pre><code>def run_simulation(self) -&gt; List[Union[float, int]]:\n    # Reset results\n    self.results = []\n\n    # Run simulation for the specified number of days\n    for day in range(self.days):\n        # Calculate result for this day\n        result = self._calculate_day_result(day)\n\n        # Store result\n        self.results.append(result)\n\n    return self.results\n</code></pre> <p>This method must: 1. Run the simulation for the specified number of days 2. Return the results as a list</p>"},{"location":"developers/creating_simulators/#parameter-information","title":"Parameter Information","text":"<pre><code>@classmethod\ndef get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n    params = super().get_parameters_info()\n    params.update({\n        'param1': {\n            'type': 'float',\n            'description': 'Description of param1',\n            'required': True\n        },\n        'param2': {\n            'type': 'str',\n            'description': 'Description of param2',\n            'required': True\n        }\n    })\n    return params\n</code></pre> <p>This method returns metadata about the simulation parameters, which is used for: 1. Documentation 2. Parameter validation 3. User interfaces</p>"},{"location":"developers/creating_simulators/#best-practices","title":"Best Practices","text":""},{"location":"developers/creating_simulators/#type-annotations","title":"Type Annotations","text":"<p>Always use type annotations for parameters and return values. This: - Improves code readability - Enables static type checking - Helps with documentation</p>"},{"location":"developers/creating_simulators/#documentation","title":"Documentation","text":"<p>Include comprehensive documentation: - Class docstring explaining what the simulation models - Parameter docstrings explaining each parameter - Method docstrings explaining each method</p>"},{"location":"developers/creating_simulators/#parameter-validation","title":"Parameter Validation","text":"<p>Validate parameters in the constructor:</p> <pre><code>def __init__(self, param1: float, ...):\n    if param1 &lt;= 0:\n        raise ValueError(\"param1 must be positive\")\n</code></pre>"},{"location":"developers/creating_simulators/#encapsulation","title":"Encapsulation","text":"<p>Use private methods (prefixed with <code>_</code>) for internal implementation details:</p> <pre><code>def _calculate_day_result(self, day: int) -&gt; float:\n    # Implementation details\n</code></pre>"},{"location":"developers/creating_simulators/#random-number-generation","title":"Random Number Generation","text":"<p>Always use the random generators initialized by the base class:</p> <pre><code># Use these:\nimport random\nimport numpy as np\n\nvalue1 = random.random()\nvalue2 = np.random.randn()\n</code></pre> <p>This ensures reproducibility when a random seed is provided.</p>"},{"location":"developers/creating_simulators/#example-complete-simulator","title":"Example: Complete Simulator","text":"<p>Here's a complete example of a simple simulator:</p> <pre><code>from sim_lab.core import BaseSimulation, SimulatorRegistry\nimport numpy as np\nfrom typing import List, Union, Optional, Dict, Any\n\n@SimulatorRegistry.register(\"RandomWalk\")\nclass RandomWalkSimulation(BaseSimulation):\n    \"\"\"Simple random walk simulation.\n\n    This simulation models a 1D random walk where the position changes\n    by a random amount each day based on a normal distribution.\n\n    Attributes:\n        start_position: The starting position for the random walk\n        step_size: The standard deviation of the normal distribution used for steps\n    \"\"\"\n\n    def __init__(\n        self,\n        days: int,\n        start_position: float = 0.0,\n        step_size: float = 1.0,\n        random_seed: Optional[int] = None\n    ):\n        \"\"\"Initialize the random walk simulation.\n\n        Args:\n            days: Duration of the simulation in days\n            start_position: The starting position for the random walk\n            step_size: The standard deviation of the normal distribution used for steps\n            random_seed: Seed for random number generation\n        \"\"\"\n        super().__init__(days=days, random_seed=random_seed)\n\n        # Validate parameters\n        if step_size &lt;= 0:\n            raise ValueError(\"step_size must be positive\")\n\n        # Store parameters\n        self.start_position = start_position\n        self.step_size = step_size\n\n        # Initialize simulation state\n        self.positions = []\n\n    def run_simulation(self) -&gt; List[float]:\n        \"\"\"Run the simulation and return results.\n\n        Returns:\n            A list of positions over time\n        \"\"\"\n        # Reset positions\n        self.positions = [self.start_position]\n\n        # Run simulation for the specified number of days\n        for day in range(1, self.days):\n            # Get previous position\n            prev_position = self.positions[-1]\n\n            # Calculate new position\n            step = np.random.normal(0, self.step_size)\n            new_position = prev_position + step\n\n            # Store new position\n            self.positions.append(new_position)\n\n        return self.positions\n\n    @classmethod\n    def get_parameters_info(cls) -&gt; Dict[str, Dict[str, Any]]:\n        \"\"\"Get information about the parameters required by this simulation.\n\n        Returns:\n            A dictionary mapping parameter names to their metadata\n        \"\"\"\n        params = super().get_parameters_info()\n        params.update({\n            'start_position': {\n                'type': 'float',\n                'description': 'The starting position for the random walk',\n                'required': False,\n                'default': 0.0\n            },\n            'step_size': {\n                'type': 'float',\n                'description': 'The standard deviation of the normal distribution used for steps',\n                'required': False,\n                'default': 1.0\n            }\n        })\n        return params\n</code></pre>"},{"location":"developers/creating_simulators/#adding-visualization","title":"Adding Visualization","text":"<p>You can add visualization methods to your simulator:</p> <pre><code>def plot_results(self, figsize=(10, 6)):\n    \"\"\"Plot the simulation results.\n\n    Args:\n        figsize: Figure size as a tuple of (width, height)\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    plt.figure(figsize=figsize)\n    plt.plot(self.positions)\n    plt.title('Random Walk Simulation')\n    plt.xlabel('Day')\n    plt.ylabel('Position')\n    plt.grid(True)\n    plt.show()\n</code></pre>"},{"location":"developers/creating_simulators/#testing-your-simulator","title":"Testing Your Simulator","text":"<p>Create tests for your simulator to ensure it works as expected:</p> <pre><code>import pytest\nfrom sim_lab.core import SimulatorRegistry\n\ndef test_random_walk():\n    # Create the simulator\n    sim = SimulatorRegistry.create(\n        \"RandomWalk\", \n        days=100, \n        start_position=10.0,\n        step_size=2.0,\n        random_seed=42\n    )\n\n    # Run the simulation\n    results = sim.run_simulation()\n\n    # Check results\n    assert len(results) == 100\n    assert results[0] == 10.0\n\n    # Check that results are deterministic with a seed\n    sim2 = SimulatorRegistry.create(\n        \"RandomWalk\", \n        days=100, \n        start_position=10.0,\n        step_size=2.0,\n        random_seed=42\n    )\n    results2 = sim2.run_simulation()\n    assert results == results2\n</code></pre>"},{"location":"developers/creating_simulators/#documentation-requirements","title":"Documentation Requirements","text":"<p>For each new simulator, provide:</p> <ol> <li>A Markdown file in the <code>docs/simulations/</code> directory</li> <li>Example usage code snippets</li> <li>Explanation of the model and its parameters</li> <li>Visualization examples</li> </ol>"},{"location":"developers/creating_simulators/#conclusion","title":"Conclusion","text":"<p>By following these guidelines, you can create robust, well-documented simulators that integrate seamlessly with the SimLab framework. The framework handles much of the boilerplate, allowing you to focus on the simulation logic specific to your model.</p>"},{"location":"developers/registry_system/","title":"Simulator Registry System","text":"<p>The SimLab registry system provides a centralized mechanism for discovering, instantiating, and managing simulation models. This guide explains how the registry works and how to use it effectively.</p>"},{"location":"developers/registry_system/#overview","title":"Overview","text":"<p>The registry system solves several important problems:</p> <ol> <li>Dynamic Discovery: Users can discover available simulation models at runtime</li> <li>Loose Coupling: Simulators are decoupled from the code that uses them</li> <li>Plugin Architecture: Third-party simulators can be registered without modifying core code</li> <li>Configuration-Based: Simulators can be specified by name in configuration files</li> <li>Centralized Management: One place to manage available simulators</li> </ol>"},{"location":"developers/registry_system/#registry-architecture","title":"Registry Architecture","text":"<p>The registry system is implemented in the <code>SimulatorRegistry</code> class, which is a singleton that maintains a mapping from simulator names to simulator classes. The core components are:</p> <ul> <li>Registry Mapping: A dictionary that maps simulator names to simulator classes</li> <li>Registration Mechanism: A decorator for registering simulator classes</li> <li>Discovery API: Methods for listing and retrieving registered simulators</li> <li>Factory Method: A method for creating instances of simulators</li> </ul>"},{"location":"developers/registry_system/#using-the-registry","title":"Using the Registry","text":""},{"location":"developers/registry_system/#registering-a-simulator","title":"Registering a Simulator","text":"<p>To register a simulator, use the <code>@SimulatorRegistry.register()</code> decorator:</p> <pre><code>from sim_lab.core import SimulatorRegistry, BaseSimulation\n\n@SimulatorRegistry.register(\"MySimulator\")\nclass MyCustomSimulation(BaseSimulation):\n    # Your simulator implementation\n    pass\n</code></pre> <p>You can also register a simulator with a different name than its class name:</p> <pre><code>@SimulatorRegistry.register(\"ShortName\")\nclass VeryLongAndDescriptiveSimulationClassName(BaseSimulation):\n    # Your simulator implementation\n    pass\n</code></pre>"},{"location":"developers/registry_system/#listing-available-simulators","title":"Listing Available Simulators","text":"<p>To list all available simulators:</p> <pre><code>from sim_lab.core import SimulatorRegistry\n\nsimulators = SimulatorRegistry.list_simulators()\nprint(f\"Available simulators: {simulators}\")\n</code></pre>"},{"location":"developers/registry_system/#creating-a-simulator-instance","title":"Creating a Simulator Instance","text":"<p>To create an instance of a simulator:</p> <pre><code>from sim_lab.core import SimulatorRegistry\n\n# Create the simulator by name\nsimulator = SimulatorRegistry.create(\n    \"MySimulator\",\n    param1=value1,\n    param2=value2\n)\n\n# Run the simulation\nresults = simulator.run_simulation()\n</code></pre>"},{"location":"developers/registry_system/#loading-simulators-dynamically","title":"Loading Simulators Dynamically","text":"<p>You can also load simulator classes from external modules:</p> <pre><code>from sim_lab.core import SimulatorRegistry\n\n# Load a simulator from a module path\nSimulatorRegistry.load_simulator_from_path(\n    module_path=\"my_package.my_module\",\n    class_name=\"MySimulatorClass\",\n    register_as=\"MyCustomSimulator\"\n)\n\n# Now you can create instances of it\nsimulator = SimulatorRegistry.create(\"MyCustomSimulator\", ...)\n</code></pre>"},{"location":"developers/registry_system/#implementation-details","title":"Implementation Details","text":""},{"location":"developers/registry_system/#the-simulatorregistry-class","title":"The SimulatorRegistry Class","text":"<p>The <code>SimulatorRegistry</code> class is a simple class with class methods that operate on a shared registry dictionary:</p> <pre><code>class SimulatorRegistry:\n    \"\"\"Registry for simulation models.\"\"\"\n\n    _registry: Dict[str, Type[BaseSimulation]] = {}\n\n    @classmethod\n    def register(cls, name: Optional[str] = None) -&gt; callable:\n        \"\"\"Decorator to register a simulation class.\"\"\"\n        def decorator(sim_class: Type[T]) -&gt; Type[T]:\n            if not inspect.isclass(sim_class) or not issubclass(sim_class, BaseSimulation):\n                raise TypeError(f\"Class {sim_class.__name__} must be a subclass of BaseSimulation\")\n\n            sim_name = name if name is not None else sim_class.__name__\n            cls._registry[sim_name] = sim_class\n            return sim_class\n\n        return decorator\n\n    @classmethod\n    def get(cls, name: str) -&gt; Type[BaseSimulation]:\n        \"\"\"Get a simulation class by name.\"\"\"\n        if name in cls._registry:\n            return cls._registry[name]\n        else:\n            raise KeyError(f\"Simulation '{name}' is not registered\")\n\n    @classmethod\n    def create(cls, name: str, **kwargs: Any) -&gt; BaseSimulation:\n        \"\"\"Create an instance of a simulation.\"\"\"\n        sim_class = cls.get(name)\n        return sim_class(**kwargs)\n\n    # ... other methods ...\n</code></pre>"},{"location":"developers/registry_system/#registration-process","title":"Registration Process","text":"<p>When a simulator class is decorated with <code>@SimulatorRegistry.register()</code>, the following happens:</p> <ol> <li>The decorator function is called with the optional name parameter</li> <li>The decorator function returns a decorator function that takes a class</li> <li>When the class is defined, the decorator function is called with the class as an argument</li> <li>The decorator function checks if the class is a subclass of <code>BaseSimulation</code></li> <li>If valid, the class is added to the registry under the specified name (or its class name)</li> <li>The original class is returned, so it can be used normally</li> </ol>"},{"location":"developers/registry_system/#class-hierarchy-and-basesimulation","title":"Class Hierarchy and BaseSimulation","text":"<p>All simulator classes must inherit from <code>BaseSimulation</code>, which provides the common interface for all simulators:</p> <pre><code>class BaseSimulation(ABC):\n    \"\"\"Base class for all SimLab simulations.\"\"\"\n\n    def __init__(self, days: int, random_seed: Optional[int] = None, **kwargs):\n        \"\"\"Initialize the base simulation.\"\"\"\n        self.days = days\n        self.random_seed = random_seed\n        self._initialize_random_generators()\n\n    @abstractmethod\n    def run_simulation(self) -&gt; List[Union[float, int]]:\n        \"\"\"Run the simulation and return results.\"\"\"\n        pass\n\n    # ... other methods ...\n</code></pre> <p>The <code>BaseSimulation</code> class defines the common interface that all simulators must implement, ensuring consistency across different simulator types.</p>"},{"location":"developers/registry_system/#best-practices","title":"Best Practices","text":""},{"location":"developers/registry_system/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Use clear, descriptive names for your simulators</li> <li>Follow PascalCase for class names and CamelCase for registry names</li> <li>Use domain-specific names that reflect the simulation's purpose</li> </ul>"},{"location":"developers/registry_system/#parameter-documentation","title":"Parameter Documentation","text":"<ul> <li>Document your simulator's parameters thoroughly using docstrings</li> <li>Implement the <code>get_parameters_info()</code> method to provide parameter metadata</li> <li>Include information about parameter types, descriptions, and defaults</li> </ul>"},{"location":"developers/registry_system/#error-handling","title":"Error Handling","text":"<ul> <li>Handle invalid parameters gracefully with clear error messages</li> <li>Validate all inputs in the constructor</li> <li>Provide helpful troubleshooting information in error messages</li> </ul>"},{"location":"developers/registry_system/#testing-registered-simulators","title":"Testing Registered Simulators","text":"<ul> <li>Test that your simulator is properly registered</li> <li>Test that your simulator can be created through the registry</li> <li>Test that your simulator works correctly when created through the registry</li> </ul>"},{"location":"developers/registry_system/#advanced-usage","title":"Advanced Usage","text":""},{"location":"developers/registry_system/#factory-patterns","title":"Factory Patterns","text":"<p>You can create factory functions that use the registry to create simulators based on configuration:</p> <pre><code>def create_simulator_from_config(config: Dict[str, Any]) -&gt; BaseSimulation:\n    \"\"\"Create a simulator from a configuration dictionary.\"\"\"\n    simulator_type = config.pop(\"type\")\n    return SimulatorRegistry.create(simulator_type, **config)\n</code></pre>"},{"location":"developers/registry_system/#registry-hooks","title":"Registry Hooks","text":"<p>You can add hooks to the registration process to perform additional tasks when simulators are registered:</p> <pre><code># Add a hook to the register method\noriginal_register = SimulatorRegistry.register\n\ndef register_with_hook(name=None):\n    decorator = original_register(name)\n\n    def wrapper(cls):\n        result = decorator(cls)\n        # Perform additional tasks here\n        print(f\"Registered simulator: {cls.__name__}\")\n        return result\n\n    return wrapper\n\nSimulatorRegistry.register = register_with_hook\n</code></pre>"},{"location":"developers/registry_system/#plugin-system","title":"Plugin System","text":"<p>You can create a plugin system that automatically discovers and registers simulators from specified directories:</p> <pre><code>import importlib\nimport pkgutil\nimport inspect\nfrom sim_lab.core import BaseSimulation, SimulatorRegistry\n\ndef discover_plugins(package_name: str) -&gt; None:\n    \"\"\"Discover and register all simulator plugins in a package.\"\"\"\n    package = importlib.import_module(package_name)\n\n    for _, module_name, _ in pkgutil.iter_modules(package.__path__, package.__name__ + \".\"):\n        module = importlib.import_module(module_name)\n\n        for name, obj in inspect.getmembers(module):\n            if (inspect.isclass(obj) and issubclass(obj, BaseSimulation) and \n                obj.__module__ == module_name and obj != BaseSimulation):\n                # Register the simulator with its class name\n                SimulatorRegistry.register()(obj)\n</code></pre>"},{"location":"developers/registry_system/#troubleshooting","title":"Troubleshooting","text":""},{"location":"developers/registry_system/#common-issues","title":"Common Issues","text":"<ol> <li>Simulator not found: Ensure the simulator is registered and imported</li> <li>Parameter errors: Check that you're providing all required parameters</li> <li>Import errors: Ensure the module path is correct when loading external simulators</li> </ol>"},{"location":"developers/registry_system/#registry-inspection","title":"Registry Inspection","text":"<p>You can inspect the registry to troubleshoot issues:</p> <pre><code>from sim_lab.core import SimulatorRegistry\nimport pprint\n\n# Print all registered simulators\npprint.pprint(SimulatorRegistry._registry)\n</code></pre>"},{"location":"developers/registry_system/#conclusion","title":"Conclusion","text":"<p>The simulator registry system provides a flexible and powerful way to manage simulation models in SimLab. By using the registry, you can create modular, extensible applications that can dynamically discover and use simulation models.</p>"},{"location":"simulations/","title":"SimLab Simulations","text":"<p>SimLab offers a comprehensive collection of simulation tools for modeling complex systems across different domains. All simulators follow a consistent interface pattern, are statically typed, and provide robust validation and error handling.</p>"},{"location":"simulations/#simulation-categories","title":"Simulation Categories","text":"<p>Our simulations are organized into the following categories:</p>"},{"location":"simulations/#basic-simulations","title":"Basic Simulations","text":"<ul> <li>Stock Market Simulation: Model stock price fluctuations with factors like volatility, drift, and market events</li> <li>Resource Fluctuations Simulation: Simulate resource price dynamics with supply disruptions</li> <li>Product Popularity Simulation: Model product demand considering growth, marketing, and promotions</li> <li>Modelling Market Dynamics: Theory behind our market dynamics models</li> </ul>"},{"location":"simulations/#discrete-event-simulations","title":"Discrete Event Simulations","text":"<ul> <li>Discrete Event Simulation: General-purpose event-driven simulation engine</li> <li>Queueing Simulation: Model service systems with arrivals, queues, and servers (coming soon)</li> </ul>"},{"location":"simulations/#statistical-simulations","title":"Statistical Simulations","text":"<ul> <li>Monte Carlo Simulation: Sample random processes to estimate numerical results (coming soon)</li> <li>Markov Chain Simulation: Model stochastic processes with the Markov property (coming soon)</li> </ul>"},{"location":"simulations/#agent-based-simulations","title":"Agent-Based Simulations","text":"<ul> <li>Agent-Based Simulation: Model complex systems through interactions of autonomous agents</li> </ul>"},{"location":"simulations/#system-dynamics","title":"System Dynamics","text":"<ul> <li>System Dynamics Simulation: Model systems with stocks, flows, and feedback loops (coming soon)</li> </ul>"},{"location":"simulations/#network-simulations","title":"Network Simulations","text":"<ul> <li>Network Simulation: Model processes on complex networks with different topologies</li> </ul>"},{"location":"simulations/#ecological-simulations","title":"Ecological Simulations","text":"<ul> <li>Predator-Prey Simulation: Model population dynamics using Lotka-Volterra equations (coming soon)</li> </ul>"},{"location":"simulations/#domain-specific-simulations","title":"Domain-Specific Simulations","text":"<ul> <li>Epidemiological Simulation: SIR/SEIR disease spread models (coming soon)</li> <li>Cellular Automaton Simulation: Grid-based models with local update rules (coming soon)</li> <li>Supply Chain Simulation: Model multi-tier supply chains with inventory management (coming soon)</li> </ul>"},{"location":"simulations/#common-features","title":"Common Features","text":"<p>All SimLab simulators share these common features:</p> <ul> <li>Consistent Interface: All simulators inherit from BaseSimulation and provide a consistent API</li> <li>Registry System: Dynamic discovery and instantiation of simulation models</li> <li>Parameter Validation: Comprehensive input validation and error handling</li> <li>Visualization Support: Integration with common plotting libraries</li> <li>Stochastic Processes: Support for random processes with seed control for reproducibility</li> <li>Extensibility: Easy to extend with custom behavior</li> </ul>"},{"location":"simulations/#getting-started","title":"Getting Started","text":"<p>To use any simulation in SimLab, follow this general pattern:</p> <pre><code>from sim_lab.core import SimulatorRegistry\n\n# Method 1: Create using the registry\nsim = SimulatorRegistry.create(\n    \"SimulatorName\",\n    param1=value1,\n    param2=value2\n)\n\n# Method 2: Create directly\nfrom sim_lab.core import SpecificSimulation\n\nsim = SpecificSimulation(\n    param1=value1,\n    param2=value2\n)\n\n# Run the simulation\nresults = sim.run_simulation()\n\n# Analyze results\n# (Each simulator provides specific methods for analysis)\n</code></pre> <p>Check the documentation for each specific simulator to learn about its parameters, methods, and examples.</p>"},{"location":"simulations/agent_based/agent_based/","title":"Agent-Based Simulation","text":"<p>Agent-Based Modeling (ABM) is a powerful approach for simulating complex systems through the actions and interactions of autonomous agents. The AgentBasedSimulation in SimLab provides a framework for creating, running, and analyzing agent-based models.</p>"},{"location":"simulations/agent_based/agent_based/#overview","title":"Overview","text":"<p>The AgentBasedSimulation class allows you to model systems where individual agents follow simple rules, yet their interactions lead to emergent behavior at the system level. Key features include:</p> <ul> <li>Customizable agent behavior</li> <li>Spatial positioning and neighborhood detection</li> <li>Environment that agents can interact with</li> <li>Metrics calculation and history tracking</li> <li>Support for various agent types and interaction patterns</li> </ul>"},{"location":"simulations/agent_based/agent_based/#basic-usage","title":"Basic Usage","text":"<p>Here's a simple example of creating and using an agent-based simulation:</p> <pre><code>from sim_lab.core import AgentBasedSimulation, Agent, Environment\nimport numpy as np\n\n# Define a custom agent class\nclass MyAgent(Agent):\n    def __init__(self, agent_id, position=None):\n        initial_state = {\n            \"energy\": 100,\n            \"alive\": True\n        }\n        super().__init__(agent_id, initial_state, position)\n\n    def update(self, environment, neighbors):\n        # Agent loses energy each step\n        self.state[\"energy\"] -= 1\n\n        # Agent dies if energy reaches 0\n        if self.state[\"energy\"] &lt;= 0:\n            self.state[\"alive\"] = False\n\n        # Agent moves randomly\n        if self.position is not None:\n            x, y = self.position\n            x += np.random.uniform(-1, 1)\n            y += np.random.uniform(-1, 1)\n            self.position = (x, y)\n\n# Define a custom environment\nclass MyEnvironment(Environment):\n    def __init__(self):\n        initial_state = {\n            \"resource_level\": 1000,\n            \"temperature\": 20\n        }\n        super().__init__(initial_state)\n\n    def update(self, agents):\n        # Resources are consumed by agents\n        alive_agents = sum(1 for agent in agents if agent.state.get(\"alive\", False))\n        consumption = alive_agents * 0.1\n        self.state[\"resource_level\"] = max(0, self.state[\"resource_level\"] - consumption)\n\n# Create an agent factory function\ndef agent_factory(agent_id):\n    return MyAgent(\n        agent_id=agent_id,\n        position=(np.random.random() * 100, np.random.random() * 100)\n    )\n\n# Create the environment\nenv = MyEnvironment()\n\n# Create the simulation\nsim = AgentBasedSimulation(\n    agent_factory=agent_factory,\n    num_agents=50,\n    environment=env,\n    days=100,\n    neighborhood_radius=10.0,\n    save_history=True\n)\n\n# Run the simulation\nmetrics = sim.run_simulation()\n\n# Analyze results\nalive_count = [m.get(\"alive_True\", 0) for m in metrics]\nprint(f\"Agents alive at the end: {alive_count[-1]}\")\n</code></pre>"},{"location":"simulations/agent_based/agent_based/#creating-agents","title":"Creating Agents","text":"<p>Agents in SimLab are created by extending the <code>Agent</code> base class:</p> <pre><code>class Agent:\n    def __init__(self, agent_id, initial_state=None, position=None):\n        self.agent_id = agent_id\n        self.state = initial_state or {}\n        self.position = position\n        self.history = []\n\n    def update(self, environment, neighbors):\n        # This method should be overridden to define agent behavior\n        pass\n\n    def move(self, new_position):\n        self.position = new_position\n\n    def get_state(self):\n        return self.state\n\n    def save_history(self):\n        self.history.append(self.state.copy())\n\n    def reset(self):\n        self.history = []\n</code></pre> <p>Your custom agents should override the <code>update</code> method to define the agent's behavior at each time step. The agent can:</p> <ul> <li>Access and modify its own state</li> <li>Interact with the environment</li> <li>Interact with neighboring agents</li> <li>Move to a new position</li> </ul>"},{"location":"simulations/agent_based/agent_based/#creating-an-environment","title":"Creating an Environment","text":"<p>The environment provides a context for the agents to operate in and can change over time:</p> <pre><code>class Environment:\n    def __init__(self, initial_state=None, bounds=(0, 0, 100, 100)):\n        self.state = initial_state or {}\n        self.bounds = bounds\n        self.history = []\n\n    def update(self, agents):\n        # This method should be overridden to define environment dynamics\n        pass\n\n    def get_state(self):\n        return self.state\n\n    def save_history(self):\n        self.history.append(self.state.copy())\n\n    def reset(self):\n        self.history = []\n</code></pre> <p>Override the <code>update</code> method to define how the environment changes based on the agents' states and actions.</p>"},{"location":"simulations/agent_based/agent_based/#simulation-parameters","title":"Simulation Parameters","text":"<p>When creating an AgentBasedSimulation, you can specify the following parameters:</p> <ul> <li>agent_factory: Function that creates new agents with given IDs</li> <li>num_agents: Number of agents to create</li> <li>environment: The environment in which agents operate</li> <li>days: Number of steps to simulate</li> <li>neighborhood_radius: Radius for determining agent neighbors</li> <li>save_history: Whether to save agent and environment history</li> <li>random_seed: Seed for random number generation</li> </ul>"},{"location":"simulations/agent_based/agent_based/#analyzing-results","title":"Analyzing Results","text":"<p>The AgentBasedSimulation class provides several methods for analyzing simulation results:</p> <pre><code># Get the history of a specific agent\nagent_history = sim.get_agent_history(agent_id=0)\n\n# Get the environment history\nenv_history = sim.get_environment_history()\n\n# Get the history of a specific metric\nmetric_history = sim.get_metric_history(metric_name=\"alive_True\")\n</code></pre>"},{"location":"simulations/agent_based/agent_based/#example-predator-prey-model","title":"Example: Predator-Prey Model","text":"<p>This example demonstrates a predator-prey ecosystem model:</p> <pre><code>from sim_lab.core import AgentBasedSimulation, Agent, Environment\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define prey agent\nclass PreyAgent(Agent):\n    def __init__(self, agent_id, position=None):\n        initial_state = {\n            \"type\": \"prey\",\n            \"energy\": 20,\n            \"age\": 0,\n            \"reproduce_countdown\": np.random.randint(5, 10)\n        }\n        super().__init__(agent_id, initial_state, position)\n\n    def update(self, environment, neighbors):\n        # Age the prey\n        self.state[\"age\"] += 1\n\n        # Lose energy\n        self.state[\"energy\"] -= 1\n\n        # Reproduce if ready\n        self.state[\"reproduce_countdown\"] -= 1\n\n        # Move away from predators\n        predators = [n for n in neighbors if n.state[\"type\"] == \"predator\"]\n        if predators:\n            # Move away from the closest predator\n            closest = predators[0]\n            dx = self.position[0] - closest.position[0]\n            dy = self.position[1] - closest.position[1]\n            dist = max(0.1, (dx**2 + dy**2)**0.5)\n\n            x, y = self.position\n            x = max(0, min(100, x + dx/dist * 3))\n            y = max(0, min(100, y + dy/dist * 3))\n            self.position = (x, y)\n        else:\n            # Random movement\n            x, y = self.position\n            x = max(0, min(100, x + np.random.uniform(-5, 5)))\n            y = max(0, min(100, y + np.random.uniform(-5, 5)))\n            self.position = (x, y)\n\n        # Find food in environment\n        if environment.state.get(\"grass\", 0) &gt; 0:\n            self.state[\"energy\"] += 5\n            environment.state[\"grass\"] -= 1\n\n# Define predator agent\nclass PredatorAgent(Agent):\n    def __init__(self, agent_id, position=None):\n        initial_state = {\n            \"type\": \"predator\",\n            \"energy\": 30,\n            \"age\": 0,\n            \"reproduce_countdown\": np.random.randint(10, 15)\n        }\n        super().__init__(agent_id, initial_state, position)\n\n    def update(self, environment, neighbors):\n        # Age the predator\n        self.state[\"age\"] += 1\n\n        # Lose energy\n        self.state[\"energy\"] -= 2\n\n        # Reproduce if ready\n        self.state[\"reproduce_countdown\"] -= 1\n\n        # Chase prey\n        prey = [n for n in neighbors if n.state[\"type\"] == \"prey\"]\n        if prey and self.state[\"energy\"] &lt; 50:\n            # Move toward the closest prey\n            closest = prey[0]\n            dx = closest.position[0] - self.position[0]\n            dy = closest.position[1] - self.position[1]\n            dist = max(0.1, (dx**2 + dy**2)**0.5)\n\n            x, y = self.position\n            x = max(0, min(100, x + dx/dist * 5))\n            y = max(0, min(100, y + dy/dist * 5))\n            self.position = (x, y)\n\n            # If close enough, eat prey\n            if dist &lt; 5:\n                self.state[\"energy\"] += 15\n                environment.state[\"prey_eaten\"] = environment.state.get(\"prey_eaten\", 0) + 1\n                closest.state[\"energy\"] = 0  # Mark for removal\n        else:\n            # Random movement\n            x, y = self.position\n            x = max(0, min(100, x + np.random.uniform(-3, 3)))\n            y = max(0, min(100, y + np.random.uniform(-3, 3)))\n            self.position = (x, y)\n\n# Define environment\nclass EcosystemEnvironment(Environment):\n    def __init__(self):\n        initial_state = {\n            \"grass\": 100,\n            \"prey_eaten\": 0,\n            \"day\": 0\n        }\n        super().__init__(initial_state)\n\n    def update(self, agents):\n        # Grow more grass\n        self.state[\"grass\"] = min(200, self.state[\"grass\"] + 5)\n        self.state[\"day\"] += 1\n\n# Create agent factory function\ndef agent_factory(agent_id):\n    if agent_id % 4 == 0:\n        return PredatorAgent(agent_id)\n    else:\n        return PreyAgent(agent_id)\n\n# Create simulation\nsim = AgentBasedSimulation(\n    agent_factory=agent_factory,\n    num_agents=100,\n    environment=EcosystemEnvironment(),\n    days=100,\n    neighborhood_radius=10.0,\n    save_history=True,\n    random_seed=42\n)\n\n# Run simulation\nmetrics = sim.run_simulation()\n\n# Extract predator and prey counts\npredator_counts = [m.get(\"type_predator\", 0) for m in metrics]\nprey_counts = [m.get(\"type_prey\", 0) for m in metrics]\n\n# Plot the results\nplt.figure(figsize=(10, 6))\nplt.plot(predator_counts, label='Predators')\nplt.plot(prey_counts, label='Prey')\nplt.title('Predator-Prey Population Dynamics')\nplt.xlabel('Time Step')\nplt.ylabel('Population')\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"simulations/agent_based/agent_based/#advanced-topics","title":"Advanced Topics","text":""},{"location":"simulations/agent_based/agent_based/#agent-communication","title":"Agent Communication","text":"<p>Agents can communicate with each other through their state attributes:</p> <pre><code>def update(self, environment, neighbors):\n    # Send a message to neighbors\n    self.state[\"message\"] = \"Hello, neighbors!\"\n\n    # Read messages from neighbors\n    for neighbor in neighbors:\n        message = neighbor.state.get(\"message\")\n        if message:\n            # Process the message\n            pass\n</code></pre>"},{"location":"simulations/agent_based/agent_based/#agent-death-and-birth","title":"Agent Death and Birth","text":"<p>Agents can \"die\" by setting a state flag that you check in metrics calculation:</p> <pre><code>def update(self, environment, neighbors):\n    if self.state[\"energy\"] &lt;= 0:\n        self.state[\"alive\"] = False\n</code></pre> <p>To add new agents during the simulation, you would need to modify the AgentBasedSimulation class to allow for agent creation and removal.</p>"},{"location":"simulations/agent_based/agent_based/#heterogeneous-agents","title":"Heterogeneous Agents","text":"<p>You can create different types of agents in your agent factory function:</p> <pre><code>def agent_factory(agent_id):\n    agent_type = agent_id % 3\n\n    if agent_type == 0:\n        return ProducerAgent(agent_id)\n    elif agent_type == 1:\n        return ConsumerAgent(agent_id)\n    else:\n        return RecyclerAgent(agent_id)\n</code></pre>"},{"location":"simulations/agent_based/agent_based/#spatial-patterns","title":"Spatial Patterns","text":"<p>Agents with position attributes can form spatial patterns:</p> <pre><code>def update(self, environment, neighbors):\n    # Flocking behavior\n    if neighbors:\n        # Calculate average position of neighbors\n        avg_x = sum(n.position[0] for n in neighbors) / len(neighbors)\n        avg_y = sum(n.position[1] for n in neighbors) / len(neighbors)\n\n        # Move toward average position\n        x, y = self.position\n        x += (avg_x - x) * 0.1\n        y += (avg_y - y) * 0.1\n        self.position = (x, y)\n</code></pre>"},{"location":"simulations/agent_based/agent_based/#api-reference","title":"API Reference","text":""},{"location":"simulations/agent_based/agent_based/#agentbasedsimulation-class","title":"AgentBasedSimulation Class","text":"<pre><code>AgentBasedSimulation(\n    agent_factory: Callable[[int], Agent],\n    num_agents: int,\n    environment: Optional[Environment] = None,\n    days: int = 100,\n    neighborhood_radius: float = 10.0,\n    save_history: bool = False,\n    random_seed: Optional[int] = None\n)\n</code></pre>"},{"location":"simulations/agent_based/agent_based/#methods","title":"Methods","text":"<ul> <li>get_agent_neighbors(agent): Get the neighbors of an agent based on proximity</li> <li>calculate_metrics(): Calculate metrics for the current simulation state</li> <li>run_simulation(): Run the agent-based simulation</li> <li>get_agent_history(agent_id): Get the state history for a specific agent</li> <li>get_environment_history(): Get the environment state history</li> <li>get_metric_history(metric_name): Get the history of a specific metric</li> </ul>"},{"location":"simulations/agent_based/agent_based/#agent-class","title":"Agent Class","text":"<pre><code>Agent(\n    agent_id: int,\n    initial_state: Dict[str, Any] = None,\n    position: Optional[Tuple[float, float]] = None\n)\n</code></pre>"},{"location":"simulations/agent_based/agent_based/#methods_1","title":"Methods","text":"<ul> <li>update(environment, neighbors): Update the agent's state</li> <li>move(new_position): Move the agent to a new position</li> <li>get_state(): Get the current state of the agent</li> <li>save_history(): Save the current state to the agent's history</li> <li>reset(): Reset the agent's history</li> </ul>"},{"location":"simulations/agent_based/agent_based/#environment-class","title":"Environment Class","text":"<pre><code>Environment(\n    initial_state: Dict[str, Any] = None,\n    bounds: Tuple[float, float, float, float] = (0, 0, 100, 100)\n)\n</code></pre>"},{"location":"simulations/agent_based/agent_based/#methods_2","title":"Methods","text":"<ul> <li>update(agents): Update the environment based on agent states</li> <li>get_state(): Get the current state of the environment</li> <li>save_history(): Save the current state to the environment's history</li> <li>reset(): Reset the environment's history</li> </ul>"},{"location":"simulations/agent_based/agent_based/#further-reading","title":"Further Reading","text":"<p>For more information about agent-based modeling, see:</p> <ul> <li>An Introduction to Agent-Based Modeling by Uri Wilensky and William Rand</li> <li>Agent-Based and Individual-Based Modeling: A Practical Introduction by Steven F. Railsback and Volker Grimm</li> <li>NetLogo - A popular platform for agent-based modeling</li> <li>Mesa - A Python framework for agent-based modeling</li> </ul>"},{"location":"simulations/basic/modelling_market_dynamics/","title":"Modeling Market Dynamics","text":"<p>This document provides a detailed overview and comparative analysis of the simulation models developed for understanding the dynamics of product popularity, stock market, and resource price fluctuations. Each model incorporates different aspects of market behavior and is loosley linked to traditional models in economics and finance.</p>"},{"location":"simulations/basic/modelling_market_dynamics/#product-popularity","title":"Product Popularity","text":"<p>The formula used in the <code>ProductPopularitySimulation</code> class for simulating product demand appears to incorporate several key factors: natural growth, marketing impact, and promotional campaigns. Here's a breakdown of how the formula works for each day of the simulation:</p> <ol> <li>Natural Growth: The natural growth of the product's demand is modeled as a simple exponential growth, which is a common model in population dynamics and economics. Each day, the demand increases by a percentage defined by the <code>growth_rate</code> attribute. The formula for this part is:</li> </ol> \\[ \\text{Natural Growth} = \\text{Previous Demand} \\times (1 + \\text{Growth Rate}) \\] <ol> <li>Marketing Impact: On top of the natural growth, the formula also includes a daily impact from ongoing marketing efforts. This impact is additive and is calculated as a percentage of the previous day's demand, determined by the <code>marketing_impact</code> attribute:</li> </ol> \\[ \\text{Marketing Influence} = \\text{Previous Demand} \\times \\text{Marketing Impact} \\] <ol> <li>Promotional Campaign: If a promotional campaign occurs on a specific day (defined by <code>promotion_day</code>), the demand for that day is further increased by a factor of <code>promotion_effectiveness</code>. This is modeled as a multiplicative boost to the demand calculated from natural growth and marketing influence:</li> </ol> \\[ \\text{New Demand} = (\\text{Natural Growth} + \\text{Marketing Influence}) \\times (1 + \\text{Promotion Effectiveness}) \\] <p>The overall formula for days without a promotional campaign is:</p> \\[ \\text{New Demand} = \\text{Natural Growth} + \\text{Marketing Influence} \\] <p>For the day with the promotional campaign, the formula changes as mentioned above.</p>"},{"location":"simulations/basic/modelling_market_dynamics/#relation-to-classical-models","title":"Relation to Classical Models","text":"<p>The model presented in the <code>ProductPopularitySimulation</code> class is not based directly on any classical single formula but instead combines concepts from various fields like marketing theory, economics, and systems dynamics: - The exponential growth model for natural increase is classical in many biological and economic models. - The impact of marketing as an additive factor is a straightforward approach often used in preliminary marketing models. - The multiplicative effect of a special promotion is also commonly used in models assessing the impact of irregular or one-time events on ongoing processes.</p> <p>The combination of these elements into a single model for simulating product demand helps in understanding how different factors interact over time to influence the market dynamics of a product. It's a practical approach that allows for adjustments and analysis of individual components like marketing strategies and promotional campaigns. This type of model can be very useful in academic settings or business analytics to forecast product demand under varying scenarios.</p>"},{"location":"simulations/basic/modelling_market_dynamics/#resource-fluctuations","title":"Resource Fluctuations","text":"<p>The formula used in the <code>ResourceFluctuationsSimulation</code> class is designed to simulate the fluctuations in resource prices, incorporating daily volatility, a trend or drift over time, and the effects of supply disruptions. Here's a breakdown of how the formula works for each day of the simulation:</p> <ol> <li>Volatility and Drift: Each day, the price of the resource changes based on a combination of volatility and drift. The volatility represents the day-to-day variability in price changes, while the drift represents a consistent trend in price changes over time. This is modeled using a normal distribution where the mean of the distribution is given by the <code>drift</code> and the standard deviation by the <code>volatility</code>. This is expressed as:</li> </ol> \\[ \\text{Random Change} = \\text{Normal}(\\text{Drift}, \\text{Volatility}) \\] <p>Then, the new price is calculated as:</p> \\[ \\text{New Price} = \\text{Previous Price} \\times (1 + \\text{Random Change}) \\] <ol> <li>Supply Disruption: If there's a day specified for a supply disruption (given by <code>supply_disruption_day</code>), the formula adjusts the price of the resource significantly based on the <code>disruption_severity</code>. The severity is modeled as a multiplicative factor to the price of the resource:</li> </ol> \\[ \\text{New Price} = \\text{Previous Price} \\times (1 + \\text{Disruption Severity}) \\]"},{"location":"simulations/basic/modelling_market_dynamics/#relation-to-classical-models_1","title":"Relation to Classical Models","text":"<p>The simulation model appears to draw from the classical geometric Brownian motion (GBM) model, which is commonly used in financial mathematics to model stock prices and other financial assets. In GBM, the logarithm of the stock prices follows a Brownian motion (also known as a Wiener process) with drift and volatility, similar to the structure used in this resource simulation class:</p> <ul> <li> <p>Geometric Brownian Motion: The use of <code>previous_price * (1 + random_change)</code> closely resembles the discrete approximation of GBM, where price changes are log-normally distributed, allowing the price to stay positive and fluctuate in a realistic manner.</p> </li> <li> <p>Supply Disruption as a Jump Process: The inclusion of supply disruption as a multiplicative effect on the price for a specific day can be seen as a form of a jump process, where the price can have sudden, significant changes due to external events. This is similar to models used in energy markets and commodities trading, where sudden events can cause significant price changes.</p> </li> </ul> <p>Overall, while the exact parameters and implementation details might differ based on the simulation's objectives and the specific market being modeled, the underlying principles of the formula are well-established in the field of quantitative finance and economic modeling.</p>"},{"location":"simulations/basic/modelling_market_dynamics/#stock-market","title":"Stock Market","text":"<p>The formula used in the <code>StockMarketSimulation</code> class simulates stock price movements by incorporating volatility, a directional trend (drift), and the impact of specific market events. Here\u2019s a detailed explanation of the components of the formula:</p> <ol> <li>Volatility and Drift: Similar to the Resource Fluctuations Simulation, the stock price changes are driven by daily volatility and drift. Each day, the stock price undergoes a random change determined by a normal distribution centered around the <code>drift</code> (which can be positive or negative to represent an overall upward or downward trend) and spread according to the <code>volatility</code> (which accounts for the unpredictability or risk associated with the stock). This is mathematically modeled as:</li> </ol> \\[ \\text{Random Change} = \\text{Normal}(\\text{Drift}, \\text{Volatility}) \\] <p>The new price for each day is then calculated as:</p> \\[ \\text{New Price} = \\text{Previous Price} \\times (1 + \\text{Random Change}) \\] <ol> <li>Market Event Impact: If there is a significant market event planned for a specific day (<code>event_day</code>), the stock price is adjusted to reflect the impact of this event using the <code>event_impact</code>, which is applied as a multiplicative factor. This adjusts the price in response to the event:</li> </ol> \\[ \\text{New Price} = \\text{Previous Price} \\times (1 + \\text{Event Impact}) \\]"},{"location":"simulations/basic/modelling_market_dynamics/#relation-to-classical-models_2","title":"Relation to Classical Models","text":"<p>The simulation model described in the <code>StockMarketSimulation</code> class aligns closely with the principles of the Geometric Brownian Motion (GBM) model used in financial mathematics to model the prices of financial instruments like stocks and commodities:</p> <ul> <li> <p>Geometric Brownian Motion: The use of a random change modeled with a normal distribution where the stock price is updated by multiplying the previous price by \\((1 + \\text{Random Change})\\) is characteristic of GBM. In GBM, prices are assumed to follow a log-normal distribution, ensuring that they remain positive and reflect realistic financial scenarios where prices are multiplicative.</p> </li> <li> <p>Event Modeling: The handling of specific market events by applying a multiplicative impact on the stock price for a particular day resembles a jump-diffusion model. This type of model is often used to incorporate sudden, significant changes in price due to external factors (such as corporate news, geopolitical events, etc.), which aren\u2019t captured by the standard GBM.</p> </li> </ul> <p>Overall, the simulation combines elements from established financial models to allow for dynamic and realistic modeling of stock prices, accommodating both the continuous aspect of daily price changes and discrete events that can significantly affect market conditions. This approach is quite common in financial market simulations used for educational purposes, trading strategy development, and risk management.</p>"},{"location":"simulations/basic/modelling_market_dynamics/#conclusion","title":"Conclusion","text":"<p>The simulation models developed for analyzing product popularity, resource fluctuations, and stock market dynamics provide valuable insights into the complex interactions within markets. By relating these models to classical and traditional theories, we can better understand the underlying mechanisms and potentially predict future behaviors under various scenarios.</p>"},{"location":"simulations/basic/product_popularity/","title":"Product Popularity Simulation","text":""},{"location":"simulations/basic/product_popularity/#purpose","title":"Purpose","text":"<p>This simulation models the dynamics of product popularity, allowing students to explore factors affecting market demand and the effectiveness of marketing strategies.</p>"},{"location":"simulations/basic/product_popularity/#parameters","title":"Parameters","text":"<ul> <li><code>start_demand</code>: The initial demand for the product.</li> <li><code>days</code>: The duration of the simulation.</li> <li><code>growth_rate</code>: The rate at which product demand grows or declines naturally over time.</li> <li><code>marketing_impact</code>: The impact of marketing efforts on demand, represented as a percentage increase.</li> <li><code>promotion_day</code>: Specifies the day on which a major marketing campaign starts (optional).</li> <li><code>promotion_effectiveness</code>: The effectiveness of the promotional campaign, impacting demand growth positively.</li> </ul>"},{"location":"simulations/basic/product_popularity/#example-code","title":"Example Code","text":"<pre><code>from simnexus import ProductPopularitySimulation\nimport matplotlib.pyplot as plt\n\n# Setting up a scenario with moderate natural growth and a significant marketing campaign.\nsim = ProductPopularitySimulation(start_demand=500, days=180, growth_rate=0.02, \n                                  marketing_impact=0.1, promotion_day=30, promotion_effectiveness=0.5)\n\ndemand = sim.run_simulation()\n\n# Visualizing product popularity\nplt.figure(figsize=(10, 6))\nplt.plot(demand, label='Product Demand')\nplt.axvline(x=sim.promotion_day, color='blue', linestyle='--', label='Marketing Campaign Start')\nplt.xlabel('Days')\nplt.ylabel('Demand Units')\nplt.title('Product Popularity Simulation')\nplt.legend()\nplt.show()\n</code></pre>"},{"location":"simulations/basic/product_popularity/#conducting-visual-analysis-using-the-simulation","title":"Conducting Visual Analysis Using the Simulation","text":"<p>Experiment! Use the simulation to explore and test various scenarios. Adjust parameters, try different strategies, and analyse the outcomes to gain deeper insights into resource management under fluctuating conditions.</p> <ul> <li> <p>Baseline Scenario Without Marketing Efforts: Begin by running simulations without any marketing efforts to understand the natural demand growth. This baseline will help you compare the effectiveness of different marketing strategies.</p> </li> <li> <p>Labeling and Annotations: Make sure your plots are well-labeled with days on the x-axis and demand units on the y-axis. Use annotations or markers to highlight when significant marketing campaigns start and their duration if applicable.</p> </li> <li> <p>Interactive Exploration: If possible, use interactive tools to adjust the parameters like growth rate, marketing impact, and timing of campaigns dynamically. This can help visualize the immediate effects of these changes on the demand curve.</p> </li> <li> <p>Comparative Analysis: Run multiple scenarios side-by-side to directly compare different growth rates, marketing impacts, or strategies. This comparison can make it easier to visualize which scenarios are most effective. Consider calculating and comparing statistics such as the average price before and after a disruption event to quantify its impact.</p> </li> </ul>"},{"location":"simulations/basic/product_popularity/#use-case-ideas","title":"Use Case Ideas","text":""},{"location":"simulations/basic/product_popularity/#examine-how-changes-in-growth-rate-and-marketing-impact-affect-demand","title":"Examine How Changes in Growth Rate and Marketing Impact Affect Demand","text":"<p>Start by considering how natural growth influences demand over time. Introduce varying levels of marketing impact and observe how each setting alters the demand curve. Questions to Consider:</p> <ul> <li> <p>How does increasing the growth rate affect the overall demand by the end of the simulation?</p> </li> <li> <p>What happens when you combine high growth rates with strong marketing impacts?</p> </li> </ul>"},{"location":"simulations/basic/product_popularity/#simulate-a-major-marketing-campaign-and-analyze-its-effect-on-demand-growth","title":"Simulate a Major Marketing Campaign and Analyze Its Effect on Demand Growth","text":"<p>Set up a scenario where a marketing campaign kicks in at a specific day. Vary the effectiveness of these campaigns to see different outcomes. Questions to Consider:</p> <ul> <li> <p>How does the timing of a marketing campaign influence its effectiveness?</p> </li> <li> <p>Compare the demand before and after the promotion day. What insights can you gain about the campaign\u2019s impact?</p> </li> </ul>"},{"location":"simulations/basic/product_popularity/#explore-different-marketing-strategies-and-their-cost-effectiveness","title":"Explore Different Marketing Strategies and Their Cost-Effectiveness","text":"<p>Implement various hypothetical marketing strategies with assumed costs and effectiveness. Calculate the return on investment (ROI) for each strategy based on the increase in demand they generate versus their costs. Questions to Consider:</p> <ul> <li> <p>Which marketing strategy offers the best ROI?</p> </li> <li> <p>How does the cost of a strategy relate to its effectiveness in boosting demand?</p> </li> </ul>"},{"location":"simulations/basic/product_popularity/#model-description","title":"Model Description","text":"<p>The Product Popularity Simulation class models the demand for a product over time, considering factors such as natural growth, marketing impact, and promotional campaigns. The simulation formula includes:</p> <ul> <li>Natural Growth: \\( \\text{Natural Growth} = \\text{Previous Demand} \\times (1 + \\text{Growth Rate}) \\)</li> <li>Marketing Influence: \\( \\text{Marketing Influence} = \\text{Previous Demand} \\times \\text{Marketing Impact} \\)</li> <li>Promotional Impact: On promotional days, the demand is further adjusted by a factor of \\( \\text{Promotion Effectiveness} \\).</li> </ul> <p>See Modelling Market Dynamics for more information.</p>"},{"location":"simulations/basic/resource_fluctuations/","title":"Resource Fluctuation Simulation","text":""},{"location":"simulations/basic/resource_fluctuations/#purpose","title":"Purpose","text":"<p>This simulation models the price fluctuations of a critical resource for a business. It is applicable to commodities, raw materials, or any essential business input, helping students understand market dynamics and pricing strategies.</p>"},{"location":"simulations/basic/resource_fluctuations/#parameters","title":"Parameters","text":"<ul> <li><code>start_price</code>: The initial price of the resource.</li> <li><code>days</code>: The duration of the simulation.</li> <li><code>volatility</code>: Controls the severity of day-to-day price fluctuations.</li> <li><code>drift</code>: Indicates the general upward or downward trend in price over time.</li> <li><code>supply_disruption_day</code>: Specifies the day on which a supply disruption event occurs (optional).</li> <li><code>disruption_severity</code>: The magnitude of the supply disruption's impact on the price, positive indicating a shortage and negative indicating a surplus.</li> </ul> <p>Example Code</p> <pre><code>from simnexus import ResourceFluctuationsSimulation\nimport matplotlib.pyplot as plt\n\n# Setting up a moderate volatility and upward drift scenario with a supply disruption.\nsim = ResourceFluctuationsSimulation(start_price=100, days=250, volatility=0.015, \n                         drift=0.0003, supply_disruption_day=100, disruption_severity=0.3) \n\nprices = sim.run_simulation()\n\n# Visualising the price simulation\nplt.figure(figsise=(10, 6))\nplt.plot(prices, label='Resource Price')\nplt.axvline(x=sim.supply_disruption_day, color='r', linestyle='--', label='Supply Disruption')\nplt.xlabel('Days')\nplt.ylabel('Price')\nplt.title('Resource Price Simulation')\nplt.legend()\nplt.show()\n</code></pre>"},{"location":"simulations/basic/resource_fluctuations/#conducting-visual-analysis-using-the-simulation","title":"Conducting Visual Analysis Using the Simulation:","text":"<p>Experiment! Use the simulation to explore and test various scenarios. Adjust parameters, try different strategies, and analyse the outcomes to gain deeper insights into resource management under fluctuating conditions.</p> <ul> <li> <p>Baseline Scenario Without Disruptions: Begin by simulating the price path without any disruptions to establish a baseline for comparison with more complex scenarios.</p> </li> <li> <p>Labeling and Annotations: Ensure that your plots clearly show the days on the x-axis and price on the y-axis. Use lines or markers to indicate the day of a supply disruption or the implementation of a hedging strategy.</p> </li> <li> <p>Interactive Exploration: If tools are available, adjust parameters such as volatility and drift dynamically to observe how these changes affect the price simulation. This can help in understanding the immediate effects of each parameter.</p> </li> <li> <p>Comparative Analysis: Conduct side-by-side comparisons of scenarios with different levels of volatility or different strategies to visually assess their impact. This can make it easier to understand which conditions or strategies lead to the most favorable outcomes.  Consider calculating and comparing statistics such as the average price before and after a disruption event to quantify its impact.</p> </li> </ul>"},{"location":"simulations/basic/resource_fluctuations/#use-case-ideas","title":"Use Case Ideas","text":""},{"location":"simulations/basic/resource_fluctuations/#assess-the-impact-of-volatility-on-price-stability","title":"Assess the Impact of Volatility on Price Stability:","text":"<p>Start by exploring how different levels of volatility affect day-to-day price fluctuations. This will help you understand the sensitivity of resource prices to changes in market conditions. Questions to Consider:</p> <ul> <li>What trends do you notice as volatility increases? How does it affect the predictability of price movements?</li> <li>How do different volatility levels impact the overall risk profile of investing in this resource?</li> </ul>"},{"location":"simulations/basic/resource_fluctuations/#model-a-supply-disruption-event-and-analyse-its-impact","title":"Model a Supply Disruption Event and Analyse Its Impact","text":"<p>Set up scenarios where a supply disruption occurs at a predetermined day. Change the severity of these disruptions to see how they influence resource prices. Questions to Consider:</p> <ul> <li>How does the timing of a supply disruption affect its impact on resource prices?</li> <li>Compare the prices before and after the disruption. What can you infer about the resilience of the market to sudden changes?</li> </ul>"},{"location":"simulations/basic/resource_fluctuations/#explore-hedging-strategies","title":"Explore Hedging Strategies","text":"<p>Implement simple hedging strategies to see how they could mitigate the risks associated with price volatility and supply disruptions. Consider strategies like futures contracts or options.Questions to Consider:</p> <ul> <li>Which hedging strategy appears most effective in stabilising price fluctuations?</li> <li>How do the costs of these strategies compare to their benefits in terms of reduced price volatility?</li> </ul>"},{"location":"simulations/basic/resource_fluctuations/#model-description","title":"Model Description","text":"<p>The Resource Fluctuations Simulation class is designed to understand the dynamics of resource price changes, incorporating volatility, market trends (drift), and supply disruptions. Key components of the simulation formula include:</p> <ul> <li>Daily Price Change: Modeled using a normal distribution influenced by drift and volatility.</li> <li>Supply Disruption: A specific day's price can be significantly altered due to external shocks, modeled as \\( \\text{Disruption Severity} \\).</li> </ul> <p>See Modelling Market Dynamics for more information.</p>"},{"location":"simulations/basic/stock_market/","title":"Stock Market Simulation","text":""},{"location":"simulations/basic/stock_market/#purpose","title":"Purpose","text":"<p>This simulation models the fluctuations of stock prices, enabling students to explore financial market dynamics and develop basic trading strategies. It serves as a practical tool for understanding the principles of market speculation and risk management.</p>"},{"location":"simulations/basic/stock_market/#parameters","title":"Parameters","text":"<ul> <li><code>start_price</code>: The initial price of the stock.</li> <li><code>days</code>: The duration of the simulation.</li> <li><code>volatility</code>: The measure of price fluctuations, indicating how much the price can vary day-to-day.</li> <li><code>drift</code>: Represents the overall trend in stock prices, whether upward or downward.</li> <li><code>event_day</code>: Specifies the day on which a major market event occurs (optional).</li> <li><code>event_impact</code>: The magnitude of the event\u2019s impact on stock prices, positive for beneficial events and negative for detrimental ones.</li> </ul> <p>Example Code</p> <pre><code>from simnexus import StockMarketSimulation\nimport matplotlib.pyplot as plt\n\n# Example scenario: High volatility with a downward price trend and a significant market event.\nsim = StockMarketSimulation(start_price=100, days=365, volatility=0.03, \n                            drift=-0.001, event_day=100, event_impact=-0.2)\n\nprices = sim.run_simulation()\n\n# Visualising the stock market fluctuations\nplt.figure(figsize=(10, 6))\nplt.plot(prices, label='Stock Price')\nplt.axvline(x=sim.event_day, color='red', linestyle='--', label='Major Market Event')\nplt.xlabel('Days')\nplt.ylabel('Price ($)')\nplt.title('Stock Market Simulation')\nplt.legend()\nplt.show()\n</code></pre>"},{"location":"simulations/basic/stock_market/#conducting-visual-analysis-using-the-simulation","title":"Conducting Visual Analysis Using the Simulation:","text":"<p>Experiment! Use the simulation to explore and test various scenarios. Adjust parameters, try different strategies, and analyse the outcomes to gain deeper insights into resource management under fluctuating conditions.</p> <ul> <li> <p>Baseline Scenario Without Disruptions: Begin by simulating the price path without any disruptions to establish a baseline for comparison with more complex scenarios.</p> </li> <li> <p>Labeling and Annotations: Ensure that your plots clearly show the days on the x-axis and price on the y-axis. Use lines or markers to indicate the day of the event or the implementation of a trading strategy.</p> </li> <li> <p>Interactive Exploration: If tools are available, adjust parameters such as volatility and drift dynamically to observe how these changes affect the price simulation. This can help in understanding the immediate effects of each parameter.</p> </li> <li> <p>Comparative Analysis: Conduct side-by-side comparisons of scenarios with different levels of volatility or different strategies to visually assess their impact. This can make it easier to understand which conditions or strategies lead to the most favorable outcomes.  Consider calculating and comparing statistics such as the average price before and after a disruption event to quantify its impact.</p> </li> </ul>"},{"location":"simulations/basic/stock_market/#use-case-ideas","title":"Use Case Ideas","text":""},{"location":"simulations/basic/stock_market/#investigate-how-volatility-affects-stock-price-stability","title":"Investigate How Volatility Affects Stock Price Stability","text":"<p>Begin by analysing how different levels of volatility impact the stability of stock prices and the potential for investment gains or losses. Questions to Consider:</p> <ul> <li> <p>How do changes in volatility affect the frequency and magnitude of price swings?</p> </li> <li> <p>What implications does increased volatility have on the risk and potential returns of stock investments?</p> </li> </ul>"},{"location":"simulations/basic/stock_market/#simulate-a-major-market-event-and-analyse-its-impact","title":"Simulate a Major Market Event and Analyse Its Impact","text":"<p>Set up scenarios where a significant market event affects stock prices on a specific day. Adjust the impact of these events to observe varying outcomes. Questions to Consider:</p> <ul> <li> <p>How does the market respond to positive versus negative events?</p> </li> <li> <p>Analyse the recovery or further decline in stock prices following the event. What does this tell you about market sentiment and investor behavior?</p> </li> </ul>"},{"location":"simulations/basic/stock_market/#develop-and-test-trading-strategies","title":"Develop and Test Trading Strategies","text":"<p>Explore basic trading strategies such as \"buy and hold\", \"moving average crossover\", or \"momentum-based\" strategies. Implement these strategies in your simulation to test their effectiveness over time. Questions to Consider:</p> <ul> <li> <p>Which strategy performs best under stable versus volatile market conditions?</p> </li> <li> <p>How do these strategies perform in response to the simulated market events?</p> </li> </ul>"},{"location":"simulations/basic/stock_market/#model-description","title":"Model Description","text":"<p>The Stock Market Simulation class focuses on the fluctuations in stock prices influenced by daily volatility, market trends, and specific market events. The simulation adjusts stock prices daily based on:</p> <ul> <li>Random daily changes due to volatility and drift.</li> <li>Event impacts that multiplicatively affect the stock prices on designated days.</li> </ul> <p>See Modelling Market Dynamics for more information.</p>"},{"location":"simulations/discrete_event/discrete_event/","title":"Discrete Event Simulation","text":"<p>Discrete Event Simulation (DES) is a modeling approach that represents systems as a sequence of events occurring at specific points in time, with each event changing the system state and potentially scheduling future events.</p>"},{"location":"simulations/discrete_event/discrete_event/#overview","title":"Overview","text":"<p>The Discrete Event Simulation in SimLab provides a flexible framework for modeling event-driven systems with the following key features:</p> <ul> <li>Event scheduling with precise timing</li> <li>Priority-based event handling</li> <li>Custom event actions</li> <li>Efficient event processing using a priority queue</li> <li>Simulation state tracking over time</li> <li>Support for stochastic processes</li> </ul>"},{"location":"simulations/discrete_event/discrete_event/#basic-usage","title":"Basic Usage","text":"<pre><code>from sim_lab.core import SimulatorRegistry\n\n# Define an event action function\ndef increment_value(simulation, data):\n    # Increase the state value\n    simulation.state[\"value\"] += data[\"amount\"]\n\n    # Schedule the next event\n    next_time = simulation.current_time + data[\"interval\"]\n    if next_time &lt;= simulation.max_time:\n        simulation.schedule_event(\n            time=next_time,\n            action=increment_value,\n            data=data\n        )\n\n# Create initial events\ninitial_events = [\n    (1.0, increment_value, {\"amount\": 5, \"interval\": 2.0})  # Start at t=1, repeat every 2 time units\n]\n\n# Create a discrete event simulation\nsim = SimulatorRegistry.create(\n    \"DiscreteEvent\",\n    max_time=20.0,\n    initial_events=initial_events,\n    time_step=1.0,\n    random_seed=42\n)\n\n# Run the simulation\nresults = sim.run_simulation()\n\n# Print the results\nfor t, value in enumerate(results):\n    print(f\"Time {t}: {value}\")\n</code></pre>"},{"location":"simulations/discrete_event/discrete_event/#parameters","title":"Parameters","text":"<p>The Discrete Event Simulation accepts the following parameters:</p> Parameter Type Description Required Default <code>max_time</code> float The maximum simulation time Yes - <code>initial_events</code> List[Tuple] Initial events as (time, action, data) tuples No None <code>time_step</code> float Time step for recording results No 1.0 <code>random_seed</code> int Seed for random number generation No None"},{"location":"simulations/discrete_event/discrete_event/#key-concepts","title":"Key Concepts","text":""},{"location":"simulations/discrete_event/discrete_event/#events","title":"Events","text":"<p>An event in the simulation is represented by the <code>Event</code> class, which includes:</p> <ul> <li>Time: When the event occurs</li> <li>Action: A function that executes when the event is processed</li> <li>Priority: For handling simultaneous events (lower number = higher priority)</li> <li>Data: Additional information associated with the event</li> </ul>"},{"location":"simulations/discrete_event/discrete_event/#event-actions","title":"Event Actions","text":"<p>Event actions are functions with the signature:</p> <pre><code>def event_action(simulation, data):\n    # Modify simulation state\n    simulation.state[\"key\"] = new_value\n\n    # Optionally schedule new events\n    simulation.schedule_event(time, action, priority, data)\n</code></pre>"},{"location":"simulations/discrete_event/discrete_event/#simulation-state","title":"Simulation State","text":"<p>The simulation maintains a state dictionary that can be modified by event actions:</p> <pre><code>simulation.state = {\"value\": 0.0, \"custom_key\": \"custom_value\"}\n</code></pre>"},{"location":"simulations/discrete_event/discrete_event/#event-queue","title":"Event Queue","text":"<p>The event queue is a priority queue that schedules events in chronological order. When multiple events occur at the same time, they are processed in order of priority.</p>"},{"location":"simulations/discrete_event/discrete_event/#example-bank-queue-simulation","title":"Example: Bank Queue Simulation","text":"<pre><code>from sim_lab.core import SimulatorRegistry\nimport random\nimport matplotlib.pyplot as plt\n\n# Customer arrival event\ndef customer_arrival(simulation, data):\n    # Increment customer count\n    simulation.state[\"total_customers\"] += 1\n    current_customer = simulation.state[\"total_customers\"]\n\n    # Add to the queue\n    simulation.state[\"queue\"].append(current_customer)\n    queue_length = len(simulation.state[\"queue\"])\n    simulation.state[\"max_queue_length\"] = max(queue_length, simulation.state[\"max_queue_length\"])\n\n    # Record queue length history\n    simulation.state[\"queue_length_history\"].append((simulation.current_time, queue_length))\n\n    # If there are idle tellers, start service immediately\n    if simulation.state[\"idle_tellers\"] &gt; 0:\n        simulation.state[\"idle_tellers\"] -= 1\n        simulation.schedule_event(\n            time=simulation.current_time,\n            action=service_start,\n            data=None\n        )\n\n    # Schedule the next arrival\n    interarrival_time = random.expovariate(1.0 / data[\"mean_interarrival\"])\n    next_arrival_time = simulation.current_time + interarrival_time\n\n    if next_arrival_time &lt; simulation.max_time:\n        simulation.schedule_event(\n            time=next_arrival_time,\n            action=customer_arrival,\n            data=data\n        )\n\n# Service start event\ndef service_start(simulation, data):\n    # Take the next customer from the queue\n    if simulation.state[\"queue\"]:\n        customer = simulation.state[\"queue\"].pop(0)\n\n        # Record queue length after customer is removed\n        queue_length = len(simulation.state[\"queue\"])\n        simulation.state[\"queue_length_history\"].append((simulation.current_time, queue_length))\n\n        # Generate service time and schedule service completion\n        service_time = random.expovariate(1.0 / simulation.state[\"mean_service_time\"])\n        simulation.schedule_event(\n            time=simulation.current_time + service_time,\n            action=service_completion,\n            data={\"customer\": customer, \"service_time\": service_time}\n        )\n\n# Service completion event\ndef service_completion(simulation, data):\n    # Record service statistics\n    wait_time = simulation.current_time - data[\"service_time\"] - simulation.state[\"arrival_times\"].get(data[\"customer\"], 0)\n    simulation.state[\"total_wait_time\"] += wait_time\n    simulation.state[\"completed_services\"] += 1\n\n    # Check if there are more customers in the queue\n    if simulation.state[\"queue\"]:\n        # Serve the next customer\n        simulation.schedule_event(\n            time=simulation.current_time,\n            action=service_start,\n            data=None\n        )\n    else:\n        # Teller becomes idle\n        simulation.state[\"idle_tellers\"] += 1\n\n# Create bank simulation using the discrete event framework\ndef run_bank_simulation(mean_interarrival=5.0, mean_service_time=3.0, num_tellers=2, simulation_time=480):\n    # Initial state\n    initial_state = {\n        \"queue\": [],                    # Customer queue\n        \"total_customers\": 0,           # Total customers that arrived\n        \"completed_services\": 0,        # Completed services\n        \"idle_tellers\": num_tellers,    # Number of idle tellers\n        \"total_wait_time\": 0,           # Total customer wait time\n        \"mean_service_time\": mean_service_time,  # Mean service time\n        \"max_queue_length\": 0,          # Maximum queue length\n        \"arrival_times\": {},            # Customer arrival times\n        \"queue_length_history\": [],     # Queue length over time\n        \"value\": 0                      # Required for the base simulation\n    }\n\n    # Initial events\n    initial_events = [\n        (0.0, customer_arrival, {\"mean_interarrival\": mean_interarrival})\n    ]\n\n    # Create and run the simulation\n    sim = SimulatorRegistry.create(\n        \"DiscreteEvent\",\n        max_time=simulation_time,\n        initial_events=initial_events,\n        time_step=1.0,\n        random_seed=42\n    )\n\n    # Set the initial state\n    sim.state = initial_state\n\n    # Run the simulation\n    sim.run_simulation()\n\n    return sim\n\n# Run the bank simulation\nbank_sim = run_bank_simulation(\n    mean_interarrival=5.0,   # Mean time between customer arrivals (minutes)\n    mean_service_time=3.0,   # Mean time to serve a customer (minutes)\n    num_tellers=2,           # Number of tellers\n    simulation_time=480      # Simulation time (minutes) - 8 hour day\n)\n\n# Extract and analyze results\ntotal_customers = bank_sim.state[\"total_customers\"]\ncompleted_services = bank_sim.state[\"completed_services\"]\navg_wait_time = bank_sim.state[\"total_wait_time\"] / completed_services if completed_services &gt; 0 else 0\nmax_queue = bank_sim.state[\"max_queue_length\"]\n\nprint(f\"Total customers: {total_customers}\")\nprint(f\"Completed services: {completed_services}\")\nprint(f\"Average wait time: {avg_wait_time:.2f} minutes\")\nprint(f\"Maximum queue length: {max_queue}\")\n\n# Plot queue length over time\ntimes, queue_lengths = zip(*bank_sim.state[\"queue_length_history\"])\nplt.figure(figsize=(12, 6))\nplt.step(times, queue_lengths, where='post')\nplt.title('Bank Queue Length Throughout the Day')\nplt.xlabel('Time (minutes)')\nplt.ylabel('Queue Length')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"simulations/discrete_event/discrete_event/#example-network-packet-simulation","title":"Example: Network Packet Simulation","text":"<pre><code>from sim_lab.core import SimulatorRegistry\nimport random\nimport matplotlib.pyplot as plt\n\n# Packet arrival event\ndef packet_arrival(simulation, data):\n    # Add packet to the buffer\n    packet_size = random.expovariate(1.0 / data[\"mean_packet_size\"])\n    simulation.state[\"buffer\"].append(packet_size)\n\n    # Update buffer statistics\n    simulation.state[\"total_packets\"] += 1\n    current_buffer_size = sum(simulation.state[\"buffer\"])\n    simulation.state[\"buffer_history\"].append((simulation.current_time, current_buffer_size))\n\n    # If the link is idle, start transmission\n    if simulation.state[\"link_state\"] == \"idle\":\n        simulation.state[\"link_state\"] = \"busy\"\n        simulation.schedule_event(\n            time=simulation.current_time,\n            action=start_transmission,\n            data=None\n        )\n\n    # Schedule the next packet arrival\n    interarrival_time = random.expovariate(1.0 / data[\"mean_interarrival\"])\n    next_arrival = simulation.current_time + interarrival_time\n\n    if next_arrival &lt; simulation.max_time:\n        simulation.schedule_event(\n            time=next_arrival,\n            action=packet_arrival,\n            data=data\n        )\n\n# Start transmission event\ndef start_transmission(simulation, data):\n    # If there are packets in the buffer, transmit the next one\n    if simulation.state[\"buffer\"]:\n        packet_size = simulation.state[\"buffer\"].pop(0)\n\n        # Calculate transmission time based on link speed\n        transmission_time = packet_size / simulation.state[\"link_speed\"]\n\n        # Schedule transmission completion\n        simulation.schedule_event(\n            time=simulation.current_time + transmission_time,\n            action=end_transmission,\n            data={\"packet_size\": packet_size}\n        )\n\n        # Update buffer size history\n        current_buffer_size = sum(simulation.state[\"buffer\"])\n        simulation.state[\"buffer_history\"].append((simulation.current_time, current_buffer_size))\n    else:\n        # No packets to transmit, link becomes idle\n        simulation.state[\"link_state\"] = \"idle\"\n\n# End transmission event\ndef end_transmission(simulation, data):\n    # Record statistics\n    simulation.state[\"transmitted_bytes\"] += data[\"packet_size\"]\n    simulation.state[\"transmitted_packets\"] += 1\n\n    # Start the next transmission if there are more packets\n    if simulation.state[\"buffer\"]:\n        simulation.schedule_event(\n            time=simulation.current_time,\n            action=start_transmission,\n            data=None\n        )\n    else:\n        # No more packets, link becomes idle\n        simulation.state[\"link_state\"] = \"idle\"\n\n# Create and run network simulation\ndef run_network_simulation(mean_interarrival=0.1, mean_packet_size=1000, link_speed=10000, simulation_time=100):\n    # Initial state\n    initial_state = {\n        \"buffer\": [],                  # Packet buffer\n        \"link_state\": \"idle\",          # Link state (idle or busy)\n        \"total_packets\": 0,            # Total packets arrived\n        \"transmitted_packets\": 0,      # Total packets transmitted\n        \"transmitted_bytes\": 0,        # Total bytes transmitted\n        \"link_speed\": link_speed,      # Link speed in bytes per second\n        \"buffer_history\": [],          # Buffer size history\n        \"value\": 0                     # Required for the base simulation\n    }\n\n    # Initial events\n    initial_events = [\n        (0.0, packet_arrival, {\"mean_interarrival\": mean_interarrival, \"mean_packet_size\": mean_packet_size})\n    ]\n\n    # Create and run the simulation\n    sim = SimulatorRegistry.create(\n        \"DiscreteEvent\",\n        max_time=simulation_time,\n        initial_events=initial_events,\n        time_step=0.1,\n        random_seed=42\n    )\n\n    # Set the initial state\n    sim.state = initial_state\n\n    # Run the simulation\n    sim.run_simulation()\n\n    return sim\n\n# Run the network simulation\nnetwork_sim = run_network_simulation(\n    mean_interarrival=0.1,     # Mean time between packet arrivals (seconds)\n    mean_packet_size=1000,     # Mean packet size (bytes)\n    link_speed=10000,          # Link speed (bytes per second)\n    simulation_time=100        # Simulation time (seconds)\n)\n\n# Extract and analyze results\ntotal_packets = network_sim.state[\"total_packets\"]\ntransmitted_packets = network_sim.state[\"transmitted_packets\"]\ntransmitted_bytes = network_sim.state[\"transmitted_bytes\"]\nthroughput = transmitted_bytes / network_sim.max_time\n\nprint(f\"Total packets: {total_packets}\")\nprint(f\"Transmitted packets: {transmitted_packets}\")\nprint(f\"Throughput: {throughput:.2f} bytes/second\")\n\n# Plot buffer size over time\ntimes, buffer_sizes = zip(*network_sim.state[\"buffer_history\"])\nplt.figure(figsize=(12, 6))\nplt.step(times, buffer_sizes, where='post')\nplt.title('Network Buffer Size Over Time')\nplt.xlabel('Time (seconds)')\nplt.ylabel('Buffer Size (bytes)')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"simulations/discrete_event/discrete_event/#advanced-topics","title":"Advanced Topics","text":""},{"location":"simulations/discrete_event/discrete_event/#event-priorities","title":"Event Priorities","text":"<p>Events with the same time are processed in order of priority:</p> <pre><code># High priority event (priority=0, the default)\nsimulation.schedule_event(\n    time=10.0,\n    action=high_priority_action,\n    priority=0,\n    data=None\n)\n\n# Low priority event (higher number = lower priority)\nsimulation.schedule_event(\n    time=10.0,\n    action=low_priority_action,\n    priority=1,\n    data=None\n)\n</code></pre>"},{"location":"simulations/discrete_event/discrete_event/#custom-state-variables","title":"Custom State Variables","text":"<p>You can add custom variables to the simulation state:</p> <pre><code>def initialize_simulation(simulation, data):\n    # Set up custom state variables\n    simulation.state[\"customers\"] = []\n    simulation.state[\"resources\"] = {\"tellers\": 3, \"managers\": 1}\n    simulation.state[\"statistics\"] = {\"wait_times\": [], \"service_times\": []}\n</code></pre>"},{"location":"simulations/discrete_event/discrete_event/#stochastic-processes","title":"Stochastic Processes","text":"<p>You can model stochastic processes using random distributions:</p> <pre><code>def exponential_event(simulation, data):\n    # Generate random time from exponential distribution\n    mean_time = data[\"mean\"]\n    random_time = random.expovariate(1.0 / mean_time)\n\n    # Schedule next event\n    next_time = simulation.current_time + random_time\n    simulation.schedule_event(\n        time=next_time,\n        action=exponential_event,\n        data=data\n    )\n</code></pre>"},{"location":"simulations/discrete_event/discrete_event/#api-reference","title":"API Reference","text":""},{"location":"simulations/discrete_event/discrete_event/#discreteeventsimulation-class","title":"DiscreteEventSimulation Class","text":"<pre><code>DiscreteEventSimulation(\n    max_time: float,\n    initial_events: List[Tuple[float, Callable, Any]] = None,\n    time_step: float = 1.0,\n    random_seed: Optional[int] = None\n)\n</code></pre>"},{"location":"simulations/discrete_event/discrete_event/#methods","title":"Methods","text":"<ul> <li>schedule_event(time, action, priority=0, data=None): Schedule a new event</li> <li>run_simulation(): Run the simulation and return results</li> <li>reset(): Reset the simulation to its initial state</li> </ul>"},{"location":"simulations/discrete_event/discrete_event/#event-class","title":"Event Class","text":"<pre><code>Event(\n    time: float,\n    action: Callable,\n    priority: int = 0,\n    data: Any = None\n)\n</code></pre>"},{"location":"simulations/discrete_event/discrete_event/#further-reading","title":"Further Reading","text":"<p>For more information about discrete event simulation:</p> <ul> <li>Introduction to Discrete-Event Simulation</li> <li>Simulation Modeling and Analysis by Averill Law</li> <li>SimPy - A Python framework for discrete event simulation</li> </ul>"},{"location":"simulations/network/network/","title":"Network Simulation","text":"<p>The Network Simulation module in SimLab allows you to model processes that occur on complex networks or graphs. This includes phenomena like information diffusion, disease spread, opinion formation, and many other network-based processes.</p>"},{"location":"simulations/network/network/#overview","title":"Overview","text":"<p>The NetworkSimulation class provides a flexible framework for simulating dynamic processes on networks with different topologies. Key features include:</p> <ul> <li>Directed and undirected networks</li> <li>Weighted edges</li> <li>Dynamic network evolution</li> <li>Support for node and edge attributes</li> <li>Built-in network metrics</li> <li>Pre-defined network generation models (Random, Scale-Free, Small-World)</li> </ul>"},{"location":"simulations/network/network/#basic-usage","title":"Basic Usage","text":"<p>Here's a simple example of creating and using a network simulation:</p> <pre><code>from sim_lab.core import NetworkSimulation, create_random_network\n\n# Create a random network with 50 nodes and 10% edge probability\nnetwork = create_random_network(\n    num_nodes=50,\n    edge_probability=0.1,\n    directed=False\n)\n\n# Define a custom update function\ndef update_function(network, day):\n    # Example: Mark random nodes as \"active\"\n    for node_id, node in network.nodes.items():\n        if np.random.random() &lt; 0.1:  # 10% chance\n            node.update_attribute(\"active\", True)\n\n# Set the update function\nnetwork.update_function = update_function\n\n# Run the simulation for 100 days\nmetrics = network.run_simulation()\n\n# Analyze the results\nnum_active = sum(1 for node in network.nodes.values() \n                 if node.attributes.get(\"active\", False))\nprint(f\"Number of active nodes: {num_active}\")\n</code></pre>"},{"location":"simulations/network/network/#pre-defined-network-models","title":"Pre-defined Network Models","text":"<p>SimLab provides built-in functions to create common network types:</p>"},{"location":"simulations/network/network/#random-network-erdosrenyi-model","title":"Random Network (Erd\u0151s\u2013R\u00e9nyi Model)","text":"<pre><code>from sim_lab.core import create_random_network\n\nrandom_net = create_random_network(\n    num_nodes=50,\n    edge_probability=0.1,\n    directed=False\n)\n</code></pre>"},{"location":"simulations/network/network/#scale-free-network-barabasialbert-model","title":"Scale-Free Network (Barab\u00e1si\u2013Albert Model)","text":"<pre><code>from sim_lab.core import create_scale_free_network\n\nscale_free_net = create_scale_free_network(\n    num_nodes=50,\n    m=2,  # Each new node attaches to m existing nodes\n    directed=False\n)\n</code></pre>"},{"location":"simulations/network/network/#small-world-network-wattsstrogatz-model","title":"Small-World Network (Watts\u2013Strogatz Model)","text":"<pre><code>from sim_lab.core import create_small_world_network\n\nsmall_world_net = create_small_world_network(\n    num_nodes=50,\n    k=4,  # Each node connects to k nearest neighbors\n    beta=0.1,  # Rewiring probability\n    directed=False\n)\n</code></pre>"},{"location":"simulations/network/network/#network-analysis","title":"Network Analysis","text":"<p>The NetworkSimulation class provides several methods for analyzing the network structure:</p> <pre><code># Get the adjacency matrix representation\nadj_matrix = network.get_adjacency_matrix()\n\n# Get the degree distribution\ndegree_dist = network.get_degree_distribution()\n\n# Calculate network metrics\nmetrics = network.calculate_metrics()\nprint(f\"Average degree: {metrics['avg_degree']}\")\nprint(f\"Network density: {metrics['density']}\")\n</code></pre>"},{"location":"simulations/network/network/#example-information-diffusion","title":"Example: Information Diffusion","text":"<p>This example shows how to simulate information diffusion through a network:</p> <pre><code>from sim_lab.core import create_scale_free_network\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create a scale-free network\nnetwork = create_scale_free_network(num_nodes=100, m=2)\n\n# Information diffusion update function\ndef diffusion_update(network, day):\n    # On day 1, seed the network with initial \"informed\" nodes\n    if day == 1:\n        for node_id in range(5):  # First 5 nodes are initially informed\n            network.nodes[node_id].update_attribute(\"informed\", True)\n            network.nodes[node_id].update_attribute(\"inform_day\", day)\n\n    # For all other days, spread the information\n    transmission_prob = 0.2  # Probability of spreading information\n\n    for node_id, node in network.nodes.items():\n        # Skip nodes that are already informed\n        if node.attributes.get(\"informed\", False):\n            continue\n\n        # Check if any neighbors are informed\n        for neighbor_id in node.neighbors:\n            if network.nodes[neighbor_id].attributes.get(\"informed\", False):\n                if np.random.random() &lt; transmission_prob:\n                    node.update_attribute(\"informed\", True)\n                    node.update_attribute(\"inform_day\", day)\n                    break\n\n# Set the update function\nnetwork.update_function = diffusion_update\n\n# Run the simulation\nnetwork.run_simulation()\n\n# Calculate the spread\ndays = network.days\ninformed_count = [0] * days\nfor day in range(days):\n    count = sum(1 for node in network.nodes.values() \n                if node.attributes.get(\"informed\", False) and \n                   node.attributes.get(\"inform_day\", float('inf')) &lt;= day)\n    informed_count[day] = count\n\n# Plot the diffusion curve\nplt.figure(figsize=(10, 6))\nplt.plot(informed_count)\nplt.title('Information Diffusion on Scale-Free Network')\nplt.xlabel('Day')\nplt.ylabel('Number of Informed Nodes')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"simulations/network/network/#api-reference","title":"API Reference","text":""},{"location":"simulations/network/network/#networksimulation-class","title":"NetworkSimulation Class","text":"<pre><code>NetworkSimulation(\n    initial_nodes: Optional[Dict[Any, Dict[str, Any]]] = None,\n    initial_edges: Optional[List[Tuple[Any, Any, Dict[str, Any]]]] = None,\n    update_function: Optional[Callable] = None,\n    directed: bool = False,\n    days: int = 100,\n    save_history: bool = False,\n    random_seed: Optional[int] = None\n)\n</code></pre>"},{"location":"simulations/network/network/#parameters","title":"Parameters","text":"<ul> <li>initial_nodes: Dictionary mapping node IDs to attribute dictionaries</li> <li>initial_edges: List of (source, target, attributes) tuples</li> <li>update_function: Function that updates the network at each time step</li> <li>directed: Whether the network is directed</li> <li>days: Number of steps to simulate</li> <li>save_history: Whether to save node and edge history</li> <li>random_seed: Seed for random number generation</li> </ul>"},{"location":"simulations/network/network/#methods","title":"Methods","text":"<ul> <li>add_node(node_id, attributes): Add a node to the network</li> <li>remove_node(node_id): Remove a node from the network</li> <li>add_edge(source, target, directed, weight, attributes): Add an edge to the network</li> <li>remove_edge(source, target): Remove an edge from the network</li> <li>get_adjacency_matrix(): Get the adjacency matrix of the network</li> <li>get_degree_distribution(): Get the degree distribution of the network</li> <li>calculate_metrics(): Calculate metrics for the current network state</li> <li>run_simulation(): Run the network simulation</li> <li>get_node_attribute_history(node_id, attribute): Get history of a node attribute</li> <li>get_edge_attribute_history(source, target, attribute): Get history of an edge attribute</li> </ul>"},{"location":"simulations/network/network/#node-class","title":"Node Class","text":"<pre><code>Node(node_id: Any, attributes: Optional[Dict[str, Any]] = None)\n</code></pre>"},{"location":"simulations/network/network/#methods_1","title":"Methods","text":"<ul> <li>add_neighbor(neighbor_id): Add a neighbor to this node</li> <li>remove_neighbor(neighbor_id): Remove a neighbor from this node</li> <li>update_attribute(key, value): Update a node attribute</li> <li>get_attribute_history(attribute): Get history of an attribute</li> </ul>"},{"location":"simulations/network/network/#edge-class","title":"Edge Class","text":"<pre><code>Edge(source: Any, target: Any, directed: bool = False, weight: float = 1.0, attributes: Optional[Dict[str, Any]] = None)\n</code></pre>"},{"location":"simulations/network/network/#methods_2","title":"Methods","text":"<ul> <li>update_weight(weight): Update the edge weight</li> <li>update_attribute(key, value): Update an edge attribute</li> <li>get_attribute_history(attribute): Get history of an attribute</li> </ul>"},{"location":"simulations/network/network/#advanced-topics","title":"Advanced Topics","text":""},{"location":"simulations/network/network/#custom-network-topology","title":"Custom Network Topology","text":"<p>You can create a custom network topology by manually specifying nodes and edges:</p> <pre><code># Create a star network topology\nnodes = {i: {} for i in range(6)}  # Center node + 5 peripheral nodes\nedges = []\n\n# Connect center node (0) to all others\nfor i in range(1, 6):\n    edges.append((0, i, {'weight': 1.0}))\n\nnetwork = NetworkSimulation(\n    initial_nodes=nodes,\n    initial_edges=edges,\n    directed=False\n)\n</code></pre>"},{"location":"simulations/network/network/#dynamic-network-evolution","title":"Dynamic Network Evolution","text":"<p>You can implement dynamic network evolution by modifying the network structure in the update function:</p> <pre><code>def dynamic_network_update(network, day):\n    # Add a new node with some probability\n    if np.random.random() &lt; 0.1:\n        new_id = max(network.nodes.keys()) + 1\n        network.add_node(new_id, {'creation_day': day})\n\n        # Connect to 2 random existing nodes\n        existing_nodes = list(network.nodes.keys())\n        if len(existing_nodes) &gt; 0:\n            for _ in range(min(2, len(existing_nodes))):\n                target = np.random.choice(existing_nodes)\n                network.add_edge(new_id, target)\n\n    # Remove a node with some probability\n    if len(network.nodes) &gt; 10 and np.random.random() &lt; 0.05:\n        node_to_remove = np.random.choice(list(network.nodes.keys()))\n        network.remove_node(node_to_remove)\n</code></pre>"},{"location":"simulations/network/network/#weighted-networks","title":"Weighted Networks","text":"<p>You can specify edge weights when creating edges:</p> <pre><code># Create a weighted network\nnodes = {i: {} for i in range(5)}\nedges = []\n\n# Add edges with different weights\nedges.append((0, 1, {'weight': 0.5}))\nedges.append((0, 2, {'weight': 1.0}))\nedges.append((1, 2, {'weight': 2.0}))\nedges.append((1, 3, {'weight': 0.7}))\nedges.append((2, 4, {'weight': 1.5}))\n\nweighted_network = NetworkSimulation(\n    initial_nodes=nodes,\n    initial_edges=edges\n)\n</code></pre>"},{"location":"simulations/network/network/#further-reading","title":"Further Reading","text":"<p>For more information about network science and related topics, see:</p> <ul> <li>Network Science by Albert-L\u00e1szl\u00f3 Barab\u00e1si</li> <li>NetworkX documentation (a popular Python library for network analysis)</li> <li>Social Network Analysis: Methods and Applications by Wasserman and Faust</li> </ul>"},{"location":"use_cases/business_modeling/","title":"Business Modeling","text":"<p>SimLab provides powerful tools for modeling business scenarios and market dynamics. This guide demonstrates how to use SimLab for various business modeling applications.</p>"},{"location":"use_cases/business_modeling/#overview","title":"Overview","text":"<p>Business modeling involves simulating market conditions, product lifecycles, resource allocation, and other business processes to gain insights and support decision-making. SimLab offers several simulators specifically designed for business applications:</p> <ul> <li>Stock Market Simulation: Model stock price fluctuations and market events</li> <li>Resource Fluctuations Simulation: Model commodity price dynamics and supply disruptions</li> <li>Product Popularity Simulation: Model product demand trends and marketing impacts</li> <li>Supply Chain Simulation: Model multi-tier supply chains with inventory management</li> </ul>"},{"location":"use_cases/business_modeling/#example-market-analysis","title":"Example: Market Analysis","text":"<p>Here's an example of using SimLab to analyze different market scenarios:</p> <pre><code>from sim_lab.core import SimulatorRegistry\nimport matplotlib.pyplot as plt\n\n# Create simulations for different market conditions\nbull_market = SimulatorRegistry.create(\n    \"StockMarket\",\n    start_price=100.0,\n    days=252,  # Trading days in a year\n    volatility=0.01,\n    drift=0.001,  # Strong positive drift\n    random_seed=42\n)\n\nbear_market = SimulatorRegistry.create(\n    \"StockMarket\",\n    start_price=100.0,\n    days=252,\n    volatility=0.02,\n    drift=-0.0005,  # Negative drift\n    random_seed=42\n)\n\n# Run simulations\nbull_prices = bull_market.run_simulation()\nbear_prices = bear_market.run_simulation()\n\n# Calculate end-of-year returns\nbull_return = (bull_prices[-1] / bull_prices[0] - 1) * 100\nbear_return = (bear_prices[-1] / bear_prices[0] - 1) * 100\n\n# Plot results\nplt.figure(figsize=(12, 6))\nplt.plot(bull_prices, 'g-', label=f'Bull Market (+{bull_return:.1f}%)')\nplt.plot(bear_prices, 'r-', label=f'Bear Market ({bear_return:.1f}%)')\nplt.title('Stock Price Scenarios')\nplt.xlabel('Trading Days')\nplt.ylabel('Price ($)')\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"use_cases/business_modeling/#example-product-launch-strategy","title":"Example: Product Launch Strategy","text":"<p>SimLab can help assess different product launch strategies:</p> <pre><code>from sim_lab.core import SimulatorRegistry\nimport matplotlib.pyplot as plt\n\n# Strategy 1: High initial marketing with promotion\nstrategy1 = SimulatorRegistry.create(\n    \"ProductPopularity\",\n    start_demand=50,\n    days=365,\n    growth_rate=0.003,\n    marketing_impact=0.005,  # High marketing spend\n    promotion_day=30,        # Launch promotion after 1 month\n    promotion_effectiveness=0.3,\n    random_seed=42\n)\n\n# Strategy 2: Gradual growth with sustained marketing\nstrategy2 = SimulatorRegistry.create(\n    \"ProductPopularity\",\n    start_demand=50,\n    days=365,\n    growth_rate=0.005,      # Higher natural growth\n    marketing_impact=0.002, # Lower marketing spend\n    random_seed=42\n)\n\n# Run simulations\ndemand1 = strategy1.run_simulation()\ndemand2 = strategy2.run_simulation()\n\n# Calculate total sales for each strategy\ntotal_sales1 = sum(demand1)\ntotal_sales2 = sum(demand2)\n\n# Plot results\nplt.figure(figsize=(12, 6))\nplt.plot(demand1, 'b-', label=f'High Marketing + Promo (Total: {total_sales1:.0f})')\nplt.plot(demand2, 'g-', label=f'Organic Growth (Total: {total_sales2:.0f})')\nplt.axvline(x=30, color='r', linestyle='--', label='Promotion')\nplt.title('Product Launch Strategies: Demand Comparison')\nplt.xlabel('Days')\nplt.ylabel('Daily Demand (units)')\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"use_cases/business_modeling/#applications-in-business-education","title":"Applications in Business Education","text":"<p>SimLab is particularly useful in business education contexts:</p> <ol> <li>MBA Programs: Students can explore market dynamics and test business strategies</li> <li>Finance Courses: Simulate trading strategies and market conditions</li> <li>Marketing Education: Model product lifecycle and marketing campaign impacts</li> <li>Supply Chain Management: Simulate inventory policies and supply disruptions</li> </ol>"},{"location":"use_cases/business_modeling/#further-resources","title":"Further Resources","text":"<p>For more specific applications, see:</p> <ul> <li>Stock Market Simulation</li> <li>Product Popularity Simulation</li> <li>Resource Fluctuations Simulation</li> </ul>"},{"location":"use_cases/educational_tools/","title":"Educational Tools","text":"<p>SimLab is designed to be an effective educational tool for teaching simulation concepts, programming, and domain-specific modeling. This guide demonstrates how to use SimLab in educational settings.</p>"},{"location":"use_cases/educational_tools/#overview","title":"Overview","text":"<p>Simulations provide a powerful way to engage students in active learning about complex systems. SimLab offers several features that make it particularly well-suited for educational contexts:</p> <ul> <li>Consistent API: All simulators follow the same pattern, minimizing cognitive load</li> <li>Multiple interfaces: CLI, TUI, Web, and Python API for different learning styles</li> <li>Visualization tools: Built-in plotting capabilities for immediate visual feedback</li> <li>Progressive complexity: From basic to advanced simulation types</li> <li>Registry system: Demonstrates software design patterns</li> </ul>"},{"location":"use_cases/educational_tools/#teaching-basic-simulation-concepts","title":"Teaching Basic Simulation Concepts","text":""},{"location":"use_cases/educational_tools/#example-demonstrating-randomness-and-seed-control","title":"Example: Demonstrating Randomness and Seed Control","text":"<pre><code>from sim_lab.core import SimulatorRegistry\nimport matplotlib.pyplot as plt\n\n# Create two simulations with different seeds\nsim1 = SimulatorRegistry.create(\n    \"StockMarket\",\n    start_price=100,\n    days=100,\n    volatility=0.02,\n    drift=0.001,\n    random_seed=42  # Fixed seed\n)\n\nsim2 = SimulatorRegistry.create(\n    \"StockMarket\",\n    start_price=100,\n    days=100,\n    volatility=0.02,\n    drift=0.001,\n    random_seed=None  # Random seed\n)\n\n# Run the simulations multiple times\nresults1 = []\nresults2 = []\n\nfor i in range(3):\n    # Run with fixed seed - should get identical results\n    prices1 = sim1.run_simulation()\n    results1.append(prices1)\n\n    # Run with no fixed seed - should get different results each time\n    prices2 = sim2.run_simulation()\n    results2.append(prices2)\n\n# Plot results\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))\n\nfor i, result in enumerate(results1):\n    ax1.plot(result, label=f'Run {i+1}')\nax1.set_title('Fixed Seed (42): Deterministic Results')\nax1.set_xlabel('Days')\nax1.set_ylabel('Price')\nax1.legend()\nax1.grid(True)\n\nfor i, result in enumerate(results2):\n    ax2.plot(result, label=f'Run {i+1}')\nax2.set_title('No Fixed Seed: Random Results')\nax2.set_xlabel('Days')\nax2.set_ylabel('Price')\nax2.legend()\nax2.grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"use_cases/educational_tools/#teaching-programming-concepts","title":"Teaching Programming Concepts","text":"<p>SimLab can be used to demonstrate various programming concepts:</p>"},{"location":"use_cases/educational_tools/#object-oriented-programming","title":"Object-Oriented Programming","text":"<pre><code>from sim_lab.core import BaseSimulation, SimulatorRegistry\nimport random\nfrom typing import List\n\n# Demonstrate subclassing and inheritance\n@SimulatorRegistry.register(\"DiceRoll\")\nclass DiceSimulation(BaseSimulation):\n    \"\"\"Simulates rolling dice.\"\"\"\n\n    def __init__(self, sides: int, num_dice: int, days: int, random_seed=None):\n        \"\"\"Initialize the simulation.\n\n        Args:\n            sides: Number of sides on each die\n            num_dice: Number of dice to roll\n            days: Number of days to simulate\n            random_seed: Random seed for reproducibility\n        \"\"\"\n        super().__init__(days=days, random_seed=random_seed)\n        self.sides = sides\n        self.num_dice = num_dice\n\n    def run_simulation(self) -&gt; List[int]:\n        \"\"\"Run the simulation.\n\n        Returns:\n            List of dice roll sums for each day\n        \"\"\"\n        results = []\n        for _ in range(self.days):\n            # Roll the dice and sum the results\n            roll_sum = sum(random.randint(1, self.sides) for _ in range(self.num_dice))\n            results.append(roll_sum)\n        return results\n\n# Create the simulation\ndice_sim = SimulatorRegistry.create(\n    \"DiceRoll\",\n    sides=6,\n    num_dice=2,\n    days=1000,\n    random_seed=42\n)\n\n# Run the simulation and analyze results\nresults = dice_sim.run_simulation()\n\n# Count frequency of each outcome\nfrequencies = {}\nfor roll in results:\n    frequencies[roll] = frequencies.get(roll, 0) + 1\n\n# Print results\nfor outcome in sorted(frequencies.keys()):\n    print(f\"Sum {outcome}: {frequencies[outcome]} times ({frequencies[outcome]/len(results)*100:.2f}%)\")\n</code></pre>"},{"location":"use_cases/educational_tools/#course-integration-ideas","title":"Course Integration Ideas","text":"<p>SimLab can be integrated into various courses:</p> <ol> <li>Computer Science:</li> <li>Data Structures and Algorithms</li> <li>Object-Oriented Programming</li> <li> <p>Software Engineering</p> </li> <li> <p>Mathematics:</p> </li> <li>Statistics and Probability</li> <li>Differential Equations</li> <li> <p>Applied Mathematics</p> </li> <li> <p>Business:</p> </li> <li>Finance and Investment</li> <li>Marketing Analytics</li> <li> <p>Operations Research</p> </li> <li> <p>Science:</p> </li> <li>Systems Biology</li> <li>Population Ecology</li> <li>Epidemiology</li> </ol>"},{"location":"use_cases/educational_tools/#assignments-and-projects","title":"Assignments and Projects","text":""},{"location":"use_cases/educational_tools/#sample-assignment-stock-market-analysis","title":"Sample Assignment: Stock Market Analysis","text":"<p>Objective: Analyze how changing parameters affects stock market simulation</p> <p>Instructions: 1. Create a stock market simulation with the following base parameters:    - start_price: 100    - days: 252 (one trading year)    - volatility: 0.015    - drift: 0.0005    - random_seed: 42</p> <ol> <li> <p>Run the simulation and record the final price and overall return.</p> </li> <li> <p>Vary each parameter individually and analyze how it affects the results:</p> </li> <li>Try volatility values: 0.005, 0.01, 0.02, 0.05</li> <li>Try drift values: -0.001, 0, 0.001, 0.002</li> <li> <p>Try different random seeds</p> </li> <li> <p>Create visualizations comparing the results.</p> </li> <li> <p>Write a brief report explaining how each parameter affects the simulation outcomes.</p> </li> </ol>"},{"location":"use_cases/educational_tools/#further-resources","title":"Further Resources","text":"<p>For more information on using SimLab for teaching, see:</p> <ul> <li>Teaching Guide</li> <li>SimLab API Reference</li> <li>Example Repository</li> </ul>"},{"location":"use_cases/scientific_simulation/","title":"Scientific Simulation","text":"<p>SimLab provides tools for scientific simulations across various domains, from ecology to epidemiology. This guide demonstrates how to use SimLab for scientific research and modeling.</p>"},{"location":"use_cases/scientific_simulation/#overview","title":"Overview","text":"<p>Scientific simulation involves creating computational models of physical, biological, or social systems to study their behavior under different conditions. SimLab offers several simulation types specifically designed for scientific applications:</p> <ul> <li>Agent-Based Simulation: Model complex systems through autonomous agent interactions</li> <li>Predator-Prey Simulation: Model ecological population dynamics</li> <li>Epidemiological Simulation: Model disease spread using SIR/SEIR models</li> <li>Network Simulation: Model processes on complex networks</li> <li>Markov Chain Simulation: Model stochastic processes with the Markov property</li> </ul>"},{"location":"use_cases/scientific_simulation/#example-predator-prey-dynamics","title":"Example: Predator-Prey Dynamics","text":"<p>Here's an example of using SimLab to model predator-prey population dynamics:</p> <pre><code>from sim_lab.core import SimulatorRegistry\nimport matplotlib.pyplot as plt\n\n# Create a predator-prey simulation\necosystem = SimulatorRegistry.create(\n    \"PredatorPrey\",\n    prey_growth_rate=0.1,      # Prey growth rate\n    predation_rate=0.02,       # Rate at which predators consume prey\n    predator_death_rate=0.1,   # Natural death rate of predators\n    predator_efficiency=0.2,   # Efficiency of converting prey to predator population\n    initial_prey=100,\n    initial_predators=15,\n    days=500,\n    random_seed=42\n)\n\n# Run the simulation\nresults = ecosystem.run_simulation()\n\n# Extract population data\nprey_pop = [day[0] for day in results]\npredator_pop = [day[1] for day in results]\n\n# Plot results\nplt.figure(figsize=(12, 6))\nplt.plot(prey_pop, 'g-', label='Prey')\nplt.plot(predator_pop, 'r-', label='Predators')\nplt.title('Predator-Prey Population Dynamics')\nplt.xlabel('Time')\nplt.ylabel('Population')\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"use_cases/scientific_simulation/#example-epidemic-modeling","title":"Example: Epidemic Modeling","text":"<p>SimLab can model disease spread within a population:</p> <pre><code>from sim_lab.core import SimulatorRegistry\nimport matplotlib.pyplot as plt\n\n# Create a SIR epidemiological model\nepidemic = SimulatorRegistry.create(\n    \"Epidemiological\",\n    model_type=\"SIR\",\n    population=10000,\n    initial_infected=10,\n    transmission_rate=0.3,\n    recovery_rate=0.1,\n    days=100,\n    random_seed=42\n)\n\n# Run the simulation\nresults = epidemic.run_simulation()\n\n# Extract population compartments\nsusceptible = [day[0] for day in results]\ninfected = [day[1] for day in results]\nrecovered = [day[2] for day in results]\n\n# Plot results\nplt.figure(figsize=(12, 6))\nplt.plot(susceptible, 'b-', label='Susceptible')\nplt.plot(infected, 'r-', label='Infected')\nplt.plot(recovered, 'g-', label='Recovered')\nplt.title('SIR Epidemic Model')\nplt.xlabel('Days')\nplt.ylabel('Population')\nplt.legend()\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"use_cases/scientific_simulation/#applications-in-scientific-research","title":"Applications in Scientific Research","text":"<p>SimLab supports various scientific research applications:</p> <ol> <li>Ecology: Model species interactions and population dynamics</li> <li>Epidemiology: Study disease spread and intervention strategies</li> <li>Physics: Simulate particle interactions and system behaviors</li> <li>Social Sciences: Model social dynamics and network effects</li> <li>Climate Science: Simulate resource fluctuations and environmental impacts</li> </ol>"},{"location":"use_cases/scientific_simulation/#monte-carlo-methods","title":"Monte Carlo Methods","text":"<p>SimLab's Monte Carlo simulation capabilities are particularly useful for scientific applications:</p> <pre><code>from sim_lab.core import SimulatorRegistry\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Create a Monte Carlo simulation to estimate \u03c0\nmc_sim = SimulatorRegistry.create(\n    \"MonteCarlo\",\n    dimensions=2,\n    samples=10000,\n    random_seed=42\n)\n\n# Define a function to check if a point is inside a unit circle\ndef point_in_circle(point):\n    x, y = point\n    return x**2 + y**2 &lt;= 1\n\n# Run the simulation\nresult = mc_sim.run_simulation(point_in_circle)\n\n# Calculate \u03c0 estimate (area of circle = \u03c0 * r\u00b2 where r=1, so \u03c0 = 4 * fraction of points in circle)\npi_estimate = 4 * result[\"result\"]\n\nprint(f\"\u03c0 estimate: {pi_estimate}\")\nprint(f\"Actual \u03c0: {np.pi}\")\nprint(f\"Error: {abs(pi_estimate - np.pi) / np.pi * 100:.6f}%\")\n</code></pre>"},{"location":"use_cases/scientific_simulation/#further-resources","title":"Further Resources","text":"<p>For more specific applications, see:</p> <ul> <li>Agent-Based Simulation</li> <li>Network Simulation</li> <li>Monte Carlo Simulation</li> </ul>"}]}